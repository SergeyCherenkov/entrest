// Code generated by ent, DO NOT EDIT.

package rest

import (
	"context"
	"fmt"
	"math"
	"slices"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/lrstanley/entrest/_examples/kitchensink/database/ent"
	"github.com/lrstanley/entrest/_examples/kitchensink/database/ent/category"
	"github.com/lrstanley/entrest/_examples/kitchensink/database/ent/follows"
	"github.com/lrstanley/entrest/_examples/kitchensink/database/ent/friendship"
	"github.com/lrstanley/entrest/_examples/kitchensink/database/ent/pet"
	"github.com/lrstanley/entrest/_examples/kitchensink/database/ent/predicate"
	"github.com/lrstanley/entrest/_examples/kitchensink/database/ent/settings"
	"github.com/lrstanley/entrest/_examples/kitchensink/database/ent/user"
)

type PageConfig struct {
	MinItemsPerPage int `json:"min_items_per_page"`
	ItemsPerPage    int `json:"items_per_page"`
	MaxItemsPerPage int `json:"max_items_per_page"`
}

var (
	firstPage = 1
	// DefaultPageConfig defines the page configuration for LIST-related endpoints
	// for all entities by default. If the configuration is not overridden for a
	// specific entity, this will be used.
	DefaultPageConfig = &PageConfig{
		MinItemsPerPage: 1,
		ItemsPerPage:    10,
		MaxItemsPerPage: 100,
	} // CategoryPageConfig defines the page configuration for LIST-related endpoints
	// for Category.
	CategoryPageConfig = &PageConfig{
		MinItemsPerPage: DefaultPageConfig.MinItemsPerPage,
		ItemsPerPage:    DefaultPageConfig.ItemsPerPage,
		MaxItemsPerPage: DefaultPageConfig.MaxItemsPerPage,
	} // FollowPageConfig defines the page configuration for LIST-related endpoints
	// for Follow.
	FollowPageConfig = &PageConfig{
		MinItemsPerPage: DefaultPageConfig.MinItemsPerPage,
		ItemsPerPage:    DefaultPageConfig.ItemsPerPage,
		MaxItemsPerPage: DefaultPageConfig.MaxItemsPerPage,
	} // FriendshipPageConfig defines the page configuration for LIST-related endpoints
	// for Friendship.
	FriendshipPageConfig = &PageConfig{
		MinItemsPerPage: DefaultPageConfig.MinItemsPerPage,
		ItemsPerPage:    DefaultPageConfig.ItemsPerPage,
		MaxItemsPerPage: DefaultPageConfig.MaxItemsPerPage,
	} // PetPageConfig defines the page configuration for LIST-related endpoints
	// for Pet.
	PetPageConfig = &PageConfig{
		MinItemsPerPage: DefaultPageConfig.MinItemsPerPage,
		ItemsPerPage:    DefaultPageConfig.ItemsPerPage,
		MaxItemsPerPage: DefaultPageConfig.MaxItemsPerPage,
	} // SettingPageConfig defines the page configuration for LIST-related endpoints
	// for Setting.
	SettingPageConfig = &PageConfig{
		MinItemsPerPage: DefaultPageConfig.MinItemsPerPage,
		ItemsPerPage:    DefaultPageConfig.ItemsPerPage,
		MaxItemsPerPage: DefaultPageConfig.MaxItemsPerPage,
	} // UserPageConfig defines the page configuration for LIST-related endpoints
	// for User.
	UserPageConfig = &PageConfig{
		MinItemsPerPage: DefaultPageConfig.MinItemsPerPage,
		ItemsPerPage:    DefaultPageConfig.ItemsPerPage,
		MaxItemsPerPage: DefaultPageConfig.MaxItemsPerPage,
	}
)

// PagableQuery is an interface for ent queries which support providing limit/offset.
type PagableQuery[P any, T any] interface {
	Limit(int) P
	Offset(int) P
	Count(ctx context.Context) (int, error)
	All(ctx context.Context) ([]*T, error)
}

// PagedResponse is the JSON response structure for paged queries.
type PagedResponse[T any] struct {
	Page       int  `json:"page"`         // Current page number.
	TotalCount int  `json:"total_count"`  // Total number of items.
	LastPage   int  `json:"last_page"`    // Last page number.
	IsLastPage bool `json:"is_last_page"` // Whether this is the last page.
	Content    []*T `json:"content"`      // Paged data.
}

// GetPage returns the current page number.
func (p *PagedResponse[T]) GetPage() int {
	return p.Page
}

// GetTotalCount returns the total number of items.
func (p *PagedResponse[T]) GetTotalCount() int {
	return p.TotalCount
}

// GetLastPage returns the last page number.
func (p *PagedResponse[T]) GetLastPage() int {
	return p.LastPage
}

// GetIsLastPage returns whether this is the last page.
func (p *PagedResponse[T]) GetIsLastPage() bool {
	return p.IsLastPage
}

type Paginated[P PagableQuery[P, T], T any] struct {
	Page         *int `json:"page"     form:"page,omitempty"`
	ItemsPerPage *int `json:"per_page" form:"per_page,omitempty"`
	ResultCount  int  `json:"-"        form:"-"` // ResultCount is populated by the query execution inside of ApplyPagination.
	LastPage     int  `json:"-"        form:"-"` // LastPage is populated by the query execution inside of ApplyPagination.

	hasApplied bool `json:"-" form:"-"`
}

// ApplyPagination applies offsets and limits, and also runs a count query on the
// provided query to calculate total results and what the last page number is.
func (p *Paginated[P, T]) ApplyPagination(ctx context.Context, query P, pageConfig *PageConfig) (P, error) {
	if pageConfig == nil {
		pageConfig = DefaultPageConfig
	}

	if p.Page == nil {
		p.Page = &firstPage
	}

	if p.ItemsPerPage == nil {
		p.ItemsPerPage = &pageConfig.ItemsPerPage
	}

	if *p.ItemsPerPage < pageConfig.MinItemsPerPage {
		return query, &ErrBadRequest{Err: fmt.Errorf("per_page %d is out of bounds, must be >= %d", *p.ItemsPerPage, pageConfig.MinItemsPerPage)}
	}

	if *p.ItemsPerPage > pageConfig.MaxItemsPerPage {
		return query, &ErrBadRequest{Err: fmt.Errorf("per_page %d is out of bounds, must be <= %d", *p.ItemsPerPage, pageConfig.MaxItemsPerPage)}
	}

	if *p.Page < 1 {
		return query, &ErrBadRequest{Err: fmt.Errorf("page %d is out of bounds, must be >= 1", *p.Page)}
	}

	var err error

	p.ResultCount, err = query.Count(ctx)
	if err != nil {
		return query, err
	}

	// TODO: how to calculate this without knowing the total count?
	p.LastPage = int(math.Ceil(float64(p.ResultCount) / float64(*p.ItemsPerPage)))

	if p.LastPage < 1 {
		p.LastPage = 1
	}

	if *p.Page > p.LastPage {
		return query, &ErrBadRequest{Err: fmt.Errorf("page %d is out of bounds, last page is %d", *p.Page, p.LastPage)}
	}

	p.hasApplied = true
	return query.Limit(*p.ItemsPerPage).Offset((*p.Page - 1) * *p.ItemsPerPage), nil
}

// ExecutePaginated executes the query and returns a paged response. If ApplyPagination
// was not called before, it will be called here.
func (p *Paginated[P, T]) ExecutePaginated(ctx context.Context, query P, pageConfig *PageConfig) (*PagedResponse[T], error) {
	if !p.hasApplied {
		var err error
		query, err = p.ApplyPagination(ctx, query, pageConfig)
		if err != nil {
			return nil, err
		}
	}

	data, err := query.All(ctx)
	if err != nil {
		return nil, err
	}

	return &PagedResponse[T]{
		Page:       *p.Page,
		TotalCount: p.ResultCount,
		LastPage:   p.LastPage,
		IsLastPage: *p.Page == p.LastPage,
		Content:    data,
	}, nil
}

type Sorted struct {
	Sort  *string `json:"sort"  form:"sort,omitempty"`
	Order *string `json:"order" form:"order,omitempty"`
}

// Validate validates the sorting fields and applies any necessary defaults.
func (s *Sorted) Validate(fields SortableFields) error {
	if s.Sort == nil {
		return nil
	}

	if !slices.Contains(fields, *s.Sort) {
		return &ErrBadRequest{Err: fmt.Errorf("invalid sort field: %s", *s.Sort)}
	}

	if s.Order == nil {
		order := "desc"
		s.Order = &order
	}

	if !slices.Contains(OrderDirections, *s.Order) {
		return &ErrBadRequest{Err: fmt.Errorf("invalid order: %s", *s.Order)}
	}

	return nil
}

// SortOrderTerm returns the OrderTermOption (Asc/Desc) based on the Order field.
func (s *Sorted) SortOrderTerm() sql.OrderTermOption {
	if *s.Order == "asc" {
		return sql.OrderAsc()
	}
	return sql.OrderDesc()
}

func (s *Sorted) SortFieldSelector() func(*sql.Selector) {
	if s.Order == nil || s.Sort == nil {
		panic("calling FieldSelector with nil sorting params")
	}

	if *s.Order == "asc" {
		return ent.Asc(*s.Sort)
	}

	return ent.Desc(*s.Sort)
}

// SortableFields is a list of sortable fields for the given entity.
type SortableFields []string

var (
	// OrderDirections are the allowed order directions that can be provided.
	OrderDirections = []string{"asc", "desc"}
	// CategorySortFields is a list of sortable fields for the "Category" entity.
	CategorySortFields = SortableFields{
		"created_at",
		"id",
		"pets.age.sum",
		"pets.count",
		"random",
		"updated_at",
	}
	// FollowSortFields is a list of sortable fields for the "Follows" entity.
	FollowSortFields = SortableFields{
		"followed_at",
		"pet.age",
		"pet.id",
		"pet.name",
		"random",
		"user.created_at",
		"user.email",
		"user.id",
		"user.name",
		"user.updated_at",
	}
	// FriendshipSortFields is a list of sortable fields for the "Friendship" entity.
	FriendshipSortFields = SortableFields{
		"friend.created_at",
		"friend.email",
		"friend.id",
		"friend.name",
		"friend.updated_at",
		"id",
		"random",
		"user.created_at",
		"user.email",
		"user.id",
		"user.name",
		"user.updated_at",
	}
	// PetSortFields is a list of sortable fields for the "Pet" entity.
	PetSortFields = SortableFields{
		"age",
		"categories.count",
		"followed_by.count",
		"following.count",
		"friends.age.sum",
		"friends.count",
		"id",
		"name",
		"owner.created_at",
		"owner.email",
		"owner.id",
		"owner.name",
		"owner.updated_at",
		"random",
	}
	// SettingSortFields is a list of sortable fields for the "Settings" entity.
	SettingSortFields = SortableFields{
		"admins.count",
		"created_at",
		"id",
		"random",
		"updated_at",
	}
	// UserSortFields is a list of sortable fields for the "User" entity.
	UserSortFields = SortableFields{
		"created_at",
		"email",
		"followed_pets.age.sum",
		"followed_pets.count",
		"following.count",
		"friends.count",
		"friendships.count",
		"id",
		"name",
		"pets.age.sum",
		"pets.count",
		"random",
		"updated_at",
	}
)

// FilterOperation represents if all or any (one or more) filters should be applied.
type FilterOperation string

const (
	FilterOperationAnd FilterOperation = "and" // Represents the "and" predicate, applying against all filters combined.
	FilterOperationOr  FilterOperation = "or"  // Represents the "or" predicate, applying against any number of filters.
)

var (
	// FilterOperations defines the available filter methods.
	FilterOperations = []FilterOperation{FilterOperationAnd, FilterOperationOr}
)

type Filtered[P ~func(*sql.Selector)] struct {
	// FilterOperation controls how multiple predicates are applied together.
	FilterOperation *FilterOperation `json:"filter_op,omitempty" form:"filter_op,omitempty"`
}

// ApplyFilterOperation applies the requested filter operation (if provided) to the
// provided predicates. If no filter operation is provided, the predicates are
// returned with AND.
func (f *Filtered[P]) ApplyFilterOperation(predicates ...P) (P, error) {
	if f.FilterOperation == nil || *f.FilterOperation == FilterOperationAnd {
		return sql.AndPredicates(predicates...), nil
	}
	if !slices.Contains(FilterOperations, *f.FilterOperation) {
		return nil, &ErrBadRequest{Err: fmt.Errorf("invalid filter method: %s", *f.FilterOperation)}
	}
	return sql.OrPredicates(predicates...), nil
}

// ListCategoryParams defines parameters for listing Categories via a GET request.
type ListCategoryParams struct {
	Sorted
	Paginated[*ent.CategoryQuery, ent.Category]
	Filtered[predicate.Category]

	// Filters field "created_at" to be greater than the provided value.
	CategoryCreatedAtGT *time.Time `form:"createdAt.gt,omitempty" json:"category_created_at_gt,omitempty"`
	// Filters field "created_at" to be less than the provided value.
	CategoryCreatedAtLT *time.Time `form:"createdAt.lt,omitempty" json:"category_created_at_lt,omitempty"`
	// Filters field "updated_at" to be greater than the provided value.
	CategoryUpdatedAtGT *time.Time `form:"updatedAt.gt,omitempty" json:"category_updated_at_gt,omitempty"`
	// Filters field "updated_at" to be less than the provided value.
	CategoryUpdatedAtLT *time.Time `form:"updatedAt.lt,omitempty" json:"category_updated_at_lt,omitempty"`
}

// FilterPredicates returns the predicates for filter-related parameters in Category.
func (l *ListCategoryParams) FilterPredicates() (predicate.Category, error) {
	var predicates []predicate.Category

	if l.CategoryCreatedAtGT != nil {
		predicates = append(predicates, category.CreatedAtGT(*l.CategoryCreatedAtGT))
	}
	if l.CategoryCreatedAtLT != nil {
		predicates = append(predicates, category.CreatedAtLT(*l.CategoryCreatedAtLT))
	}
	if l.CategoryUpdatedAtGT != nil {
		predicates = append(predicates, category.UpdatedAtGT(*l.CategoryUpdatedAtGT))
	}
	if l.CategoryUpdatedAtLT != nil {
		predicates = append(predicates, category.UpdatedAtLT(*l.CategoryUpdatedAtLT))
	}
	return l.ApplyFilterOperation(predicates...)
}

// ApplySorting applies sorting to the query based on the provided sort and order fields.
func (l *ListCategoryParams) ApplySorting(query *ent.CategoryQuery) (*ent.CategoryQuery, error) {
	if l.Sort == nil {
		return query, nil
	}
	if err := l.Sorted.Validate(CategorySortFields); err != nil {
		return nil, err
	}
	if parts := strings.Split(*l.Sort, "."); len(parts) > 1 {
		dir := l.Sorted.SortOrderTerm()

		var isCount, isSum bool
		if len(parts) > 2 {
			switch parts[2] {
			case "count":
				isCount = true
			case "sum":
				isSum = true
			}
		}

		switch parts[0] {
		case category.EdgePets:
			switch {
			case isCount:
				return query.Order(category.ByPetsCount(dir)), nil
			case isSum:
				return query.Order(category.ByPets(sql.OrderBySum(parts[1], dir))), nil
			default:
				return query.Order(category.ByPets(sql.OrderByField(parts[1], dir))), nil
			}
		}
	}
	if *l.Sort == "random" {
		return query.Order(sql.OrderByRand()), nil
	}
	return query.Order(l.Sorted.SortFieldSelector()), nil
}

// Exec wraps all logic (filtering, sorting, pagination, eager loading) and
// executes all necessary queries, returning the results.
func (l *ListCategoryParams) Exec(ctx context.Context, query *ent.CategoryQuery) (results *PagedResponse[ent.Category], err error) {
	predicates, err := l.FilterPredicates()
	if err != nil {
		return nil, err
	}
	query = query.Where(predicates)
	query, err = l.ApplySorting(EagerLoadCategory(query))
	if err != nil {
		return nil, err
	}
	return l.ExecutePaginated(ctx, query, CategoryPageConfig)
}

// ListFollowParams defines parameters for listing Follows via a GET request.
type ListFollowParams struct {
	Sorted
	Paginated[*ent.FollowsQuery, ent.Follows]
}

// ApplySorting applies sorting to the query based on the provided sort and order fields.
func (l *ListFollowParams) ApplySorting(query *ent.FollowsQuery) (*ent.FollowsQuery, error) {
	if l.Sort == nil {
		return query, nil
	}
	if err := l.Sorted.Validate(FollowSortFields); err != nil {
		return nil, err
	}
	if parts := strings.Split(*l.Sort, "."); len(parts) > 1 {
		dir := l.Sorted.SortOrderTerm()

		switch parts[0] {
		case follows.EdgeUser:
			return query.Order(follows.ByUserField(parts[1], dir)), nil
		case follows.EdgePet:
			return query.Order(follows.ByPetField(parts[1], dir)), nil
		}
	}
	if *l.Sort == "random" {
		return query.Order(sql.OrderByRand()), nil
	}
	return query.Order(l.Sorted.SortFieldSelector()), nil
}

// Exec wraps all logic (filtering, sorting, pagination, eager loading) and
// executes all necessary queries, returning the results.
func (l *ListFollowParams) Exec(ctx context.Context, query *ent.FollowsQuery) (results *PagedResponse[ent.Follows], err error) {
	query, err = l.ApplySorting(EagerLoadFollow(query))
	if err != nil {
		return nil, err
	}
	return l.ExecutePaginated(ctx, query, FollowPageConfig)
}

// ListFriendshipParams defines parameters for listing Friendships via a GET request.
type ListFriendshipParams struct {
	Sorted
	Paginated[*ent.FriendshipQuery, ent.Friendship]
}

// ApplySorting applies sorting to the query based on the provided sort and order fields.
func (l *ListFriendshipParams) ApplySorting(query *ent.FriendshipQuery) (*ent.FriendshipQuery, error) {
	if l.Sort == nil {
		return query, nil
	}
	if err := l.Sorted.Validate(FriendshipSortFields); err != nil {
		return nil, err
	}
	if parts := strings.Split(*l.Sort, "."); len(parts) > 1 {
		dir := l.Sorted.SortOrderTerm()

		switch parts[0] {
		case friendship.EdgeUser:
			return query.Order(friendship.ByUserField(parts[1], dir)), nil
		case friendship.EdgeFriend:
			return query.Order(friendship.ByFriendField(parts[1], dir)), nil
		}
	}
	if *l.Sort == "random" {
		return query.Order(sql.OrderByRand()), nil
	}
	return query.Order(l.Sorted.SortFieldSelector()), nil
}

// Exec wraps all logic (filtering, sorting, pagination, eager loading) and
// executes all necessary queries, returning the results.
func (l *ListFriendshipParams) Exec(ctx context.Context, query *ent.FriendshipQuery) (results *PagedResponse[ent.Friendship], err error) {
	query, err = l.ApplySorting(EagerLoadFriendship(query))
	if err != nil {
		return nil, err
	}
	return l.ExecutePaginated(ctx, query, FriendshipPageConfig)
}

// ListPetParams defines parameters for listing Pets via a GET request.
type ListPetParams struct {
	Sorted
	Paginated[*ent.PetQuery, ent.Pet]
	Filtered[predicate.Pet]

	// Filters field "name" to be equal to the provided value.
	PetNameEQ *string `form:"name.eq,omitempty" json:"pet_name_eq,omitempty"`
	// Filters field "name" to be not equal to the provided value.
	PetNameNEQ *string `form:"name.neq,omitempty" json:"pet_name_neq,omitempty"`
	// Filters field "name" to be within the provided values.
	PetNameIn []string `form:"name.in,omitempty" json:"pet_name_in,omitempty"`
	// Filters field "name" to be not within the provided values.
	PetNameNotIn []string `form:"name.notIn,omitempty" json:"pet_name_not_in,omitempty"`
	// Filters field "name" to contain the provided value.
	PetNameContains *string `form:"name.has,omitempty" json:"pet_name_contains,omitempty"`
	// Filters field "name" to start with the provided value.
	PetNameHasPrefix *string `form:"name.prefix,omitempty" json:"pet_name_has_prefix,omitempty"`
	// Filters field "name" to end with the provided value.
	PetNameHasSuffix *string `form:"name.suffix,omitempty" json:"pet_name_has_suffix,omitempty"`
	// Filters field "name" to be equal to the provided value, case-insensitive.
	PetNameEqualFold *string `form:"name.ieq,omitempty" json:"pet_name_equal_fold,omitempty"`
	// Filters field "name" to contain the provided value, case-insensitive.
	PetNameContainsFold *string `form:"name.ihas,omitempty" json:"pet_name_contains_fold,omitempty"`
	// Filters field "nicknames" to be null/nil.
	PetNicknamesIsNil *bool `form:"nicknames.null,omitempty" json:"pet_nicknames_is_nil,omitempty"`
	// Filters field "age" to be equal to the provided value.
	PetAgeEQ *int `form:"age.eq,omitempty" json:"pet_age_eq,omitempty"`
	// Filters field "age" to be not equal to the provided value.
	PetAgeNEQ *int `form:"age.neq,omitempty" json:"pet_age_neq,omitempty"`
	// Filters field "age" to be within the provided values.
	PetAgeIn []int `form:"age.in,omitempty" json:"pet_age_in,omitempty"`
	// Filters field "age" to be not within the provided values.
	PetAgeNotIn []int `form:"age.notIn,omitempty" json:"pet_age_not_in,omitempty"`
	// Filters field "age" to be greater than the provided value.
	PetAgeGT *int `form:"age.gt,omitempty" json:"pet_age_gt,omitempty"`
	// Filters field "age" to be less than the provided value.
	PetAgeLT *int `form:"age.lt,omitempty" json:"pet_age_lt,omitempty"`
	// Filters field "age" to be null/nil.
	PetAgeIsNil *bool `form:"age.null,omitempty" json:"pet_age_is_nil,omitempty"`
	// If true, only return entities that have a category edge.
	EdgeHasCategory *bool `form:"has.category,omitempty" json:"edge_has_category,omitempty"`
	// Filters field "created_at" to be greater than the provided value.
	EdgeCategoryCreatedAtGT *time.Time `form:"category.createdAt.gt,omitempty" json:"edge_category_created_at_gt,omitempty"`
	// Filters field "created_at" to be less than the provided value.
	EdgeCategoryCreatedAtLT *time.Time `form:"category.createdAt.lt,omitempty" json:"edge_category_created_at_lt,omitempty"`
	// Filters field "updated_at" to be greater than the provided value.
	EdgeCategoryUpdatedAtGT *time.Time `form:"category.updatedAt.gt,omitempty" json:"edge_category_updated_at_gt,omitempty"`
	// Filters field "updated_at" to be less than the provided value.
	EdgeCategoryUpdatedAtLT *time.Time `form:"category.updatedAt.lt,omitempty" json:"edge_category_updated_at_lt,omitempty"`
	// If true, only return entities that have a owner edge.
	EdgeHasOwner *bool `form:"has.owner,omitempty" json:"edge_has_owner,omitempty"`
	// Filters field "created_at" to be greater than the provided value.
	EdgeOwnerCreatedAtGT *time.Time `form:"owner.createdAt.gt,omitempty" json:"edge_owner_created_at_gt,omitempty"`
	// Filters field "created_at" to be less than the provided value.
	EdgeOwnerCreatedAtLT *time.Time `form:"owner.createdAt.lt,omitempty" json:"edge_owner_created_at_lt,omitempty"`
	// Filters field "updated_at" to be greater than the provided value.
	EdgeOwnerUpdatedAtGT *time.Time `form:"owner.updatedAt.gt,omitempty" json:"edge_owner_updated_at_gt,omitempty"`
	// Filters field "updated_at" to be less than the provided value.
	EdgeOwnerUpdatedAtLT *time.Time `form:"owner.updatedAt.lt,omitempty" json:"edge_owner_updated_at_lt,omitempty"`
	// Filters field "name" to be equal to the provided value.
	EdgeOwnerNameEQ *string `form:"owner.name.eq,omitempty" json:"edge_owner_name_eq,omitempty"`
	// Filters field "name" to be not equal to the provided value.
	EdgeOwnerNameNEQ *string `form:"owner.name.neq,omitempty" json:"edge_owner_name_neq,omitempty"`
	// Filters field "name" to be within the provided values.
	EdgeOwnerNameIn []string `form:"owner.name.in,omitempty" json:"edge_owner_name_in,omitempty"`
	// Filters field "name" to be not within the provided values.
	EdgeOwnerNameNotIn []string `form:"owner.name.notIn,omitempty" json:"edge_owner_name_not_in,omitempty"`
	// Filters field "name" to contain the provided value.
	EdgeOwnerNameContains *string `form:"owner.name.has,omitempty" json:"edge_owner_name_contains,omitempty"`
	// Filters field "name" to start with the provided value.
	EdgeOwnerNameHasPrefix *string `form:"owner.name.prefix,omitempty" json:"edge_owner_name_has_prefix,omitempty"`
	// Filters field "name" to end with the provided value.
	EdgeOwnerNameHasSuffix *string `form:"owner.name.suffix,omitempty" json:"edge_owner_name_has_suffix,omitempty"`
	// Filters field "name" to be equal to the provided value, case-insensitive.
	EdgeOwnerNameEqualFold *string `form:"owner.name.ieq,omitempty" json:"edge_owner_name_equal_fold,omitempty"`
	// Filters field "name" to contain the provided value, case-insensitive.
	EdgeOwnerNameContainsFold *string `form:"owner.name.ihas,omitempty" json:"edge_owner_name_contains_fold,omitempty"`
	// Filters field "type" to be equal to the provided value.
	EdgeOwnerTypeEQ *user.Type `form:"owner.type.eq,omitempty" json:"edge_owner_type_eq,omitempty"`
	// Filters field "type" to be not equal to the provided value.
	EdgeOwnerTypeNEQ *user.Type `form:"owner.type.neq,omitempty" json:"edge_owner_type_neq,omitempty"`
	// Filters field "type" to be within the provided values.
	EdgeOwnerTypeIn []user.Type `form:"owner.type.in,omitempty" json:"edge_owner_type_in,omitempty"`
	// Filters field "type" to be not within the provided values.
	EdgeOwnerTypeNotIn []user.Type `form:"owner.type.notIn,omitempty" json:"edge_owner_type_not_in,omitempty"`
	// Filters field "description" to contain the provided value.
	EdgeOwnerDescriptionContains *string `form:"owner.description.has,omitempty" json:"edge_owner_description_contains,omitempty"`
	// Filters field "description" to be null/nil.
	EdgeOwnerDescriptionIsNil *bool `form:"owner.description.null,omitempty" json:"edge_owner_description_is_nil,omitempty"`
	// Filters field "description" to contain the provided value, case-insensitive.
	EdgeOwnerDescriptionContainsFold *string `form:"owner.description.ihas,omitempty" json:"edge_owner_description_contains_fold,omitempty"`
	// Filters field "enabled" to be equal to the provided value.
	EdgeOwnerEnabledEQ *bool `form:"owner.enabled.eq,omitempty" json:"edge_owner_enabled_eq,omitempty"`
	// Filters field "email" to be equal to the provided value.
	EdgeOwnerEmailEQ *string `form:"owner.email.eq,omitempty" json:"edge_owner_email_eq,omitempty"`
	// Filters field "email" to be not equal to the provided value.
	EdgeOwnerEmailNEQ *string `form:"owner.email.neq,omitempty" json:"edge_owner_email_neq,omitempty"`
	// Filters field "email" to be within the provided values.
	EdgeOwnerEmailIn []string `form:"owner.email.in,omitempty" json:"edge_owner_email_in,omitempty"`
	// Filters field "email" to be not within the provided values.
	EdgeOwnerEmailNotIn []string `form:"owner.email.notIn,omitempty" json:"edge_owner_email_not_in,omitempty"`
	// Filters field "email" to contain the provided value.
	EdgeOwnerEmailContains *string `form:"owner.email.has,omitempty" json:"edge_owner_email_contains,omitempty"`
	// Filters field "email" to start with the provided value.
	EdgeOwnerEmailHasPrefix *string `form:"owner.email.prefix,omitempty" json:"edge_owner_email_has_prefix,omitempty"`
	// Filters field "email" to end with the provided value.
	EdgeOwnerEmailHasSuffix *string `form:"owner.email.suffix,omitempty" json:"edge_owner_email_has_suffix,omitempty"`
	// Filters field "email" to be null/nil.
	EdgeOwnerEmailIsNil *bool `form:"owner.email.null,omitempty" json:"edge_owner_email_is_nil,omitempty"`
	// Filters field "email" to be equal to the provided value, case-insensitive.
	EdgeOwnerEmailEqualFold *string `form:"owner.email.ieq,omitempty" json:"edge_owner_email_equal_fold,omitempty"`
	// Filters field "email" to contain the provided value, case-insensitive.
	EdgeOwnerEmailContainsFold *string `form:"owner.email.ihas,omitempty" json:"edge_owner_email_contains_fold,omitempty"`
	// If true, only return entities that have a friend edge.
	EdgeHasFriend *bool `form:"has.friend,omitempty" json:"edge_has_friend,omitempty"`
	// Filters field "name" to be equal to the provided value.
	EdgeFriendNameEQ *string `form:"friend.name.eq,omitempty" json:"edge_friend_name_eq,omitempty"`
	// Filters field "name" to be not equal to the provided value.
	EdgeFriendNameNEQ *string `form:"friend.name.neq,omitempty" json:"edge_friend_name_neq,omitempty"`
	// Filters field "name" to be within the provided values.
	EdgeFriendNameIn []string `form:"friend.name.in,omitempty" json:"edge_friend_name_in,omitempty"`
	// Filters field "name" to be not within the provided values.
	EdgeFriendNameNotIn []string `form:"friend.name.notIn,omitempty" json:"edge_friend_name_not_in,omitempty"`
	// Filters field "name" to contain the provided value.
	EdgeFriendNameContains *string `form:"friend.name.has,omitempty" json:"edge_friend_name_contains,omitempty"`
	// Filters field "name" to start with the provided value.
	EdgeFriendNameHasPrefix *string `form:"friend.name.prefix,omitempty" json:"edge_friend_name_has_prefix,omitempty"`
	// Filters field "name" to end with the provided value.
	EdgeFriendNameHasSuffix *string `form:"friend.name.suffix,omitempty" json:"edge_friend_name_has_suffix,omitempty"`
	// Filters field "name" to be equal to the provided value, case-insensitive.
	EdgeFriendNameEqualFold *string `form:"friend.name.ieq,omitempty" json:"edge_friend_name_equal_fold,omitempty"`
	// Filters field "name" to contain the provided value, case-insensitive.
	EdgeFriendNameContainsFold *string `form:"friend.name.ihas,omitempty" json:"edge_friend_name_contains_fold,omitempty"`
	// Filters field "nicknames" to be null/nil.
	EdgeFriendNicknamesIsNil *bool `form:"friend.nicknames.null,omitempty" json:"edge_friend_nicknames_is_nil,omitempty"`
	// Filters field "age" to be equal to the provided value.
	EdgeFriendAgeEQ *int `form:"friend.age.eq,omitempty" json:"edge_friend_age_eq,omitempty"`
	// Filters field "age" to be not equal to the provided value.
	EdgeFriendAgeNEQ *int `form:"friend.age.neq,omitempty" json:"edge_friend_age_neq,omitempty"`
	// Filters field "age" to be within the provided values.
	EdgeFriendAgeIn []int `form:"friend.age.in,omitempty" json:"edge_friend_age_in,omitempty"`
	// Filters field "age" to be not within the provided values.
	EdgeFriendAgeNotIn []int `form:"friend.age.notIn,omitempty" json:"edge_friend_age_not_in,omitempty"`
	// Filters field "age" to be greater than the provided value.
	EdgeFriendAgeGT *int `form:"friend.age.gt,omitempty" json:"edge_friend_age_gt,omitempty"`
	// Filters field "age" to be less than the provided value.
	EdgeFriendAgeLT *int `form:"friend.age.lt,omitempty" json:"edge_friend_age_lt,omitempty"`
	// Filters field "age" to be null/nil.
	EdgeFriendAgeIsNil *bool `form:"friend.age.null,omitempty" json:"edge_friend_age_is_nil,omitempty"`
	// If true, only return entities that have a followed_by edge.
	EdgeHasFollowedBy *bool `form:"has.followedBy,omitempty" json:"edge_has_followed_by,omitempty"`
	// Filters field "created_at" to be greater than the provided value.
	EdgeFollowedByCreatedAtGT *time.Time `form:"followedBy.createdAt.gt,omitempty" json:"edge_followed_by_created_at_gt,omitempty"`
	// Filters field "created_at" to be less than the provided value.
	EdgeFollowedByCreatedAtLT *time.Time `form:"followedBy.createdAt.lt,omitempty" json:"edge_followed_by_created_at_lt,omitempty"`
	// Filters field "updated_at" to be greater than the provided value.
	EdgeFollowedByUpdatedAtGT *time.Time `form:"followedBy.updatedAt.gt,omitempty" json:"edge_followed_by_updated_at_gt,omitempty"`
	// Filters field "updated_at" to be less than the provided value.
	EdgeFollowedByUpdatedAtLT *time.Time `form:"followedBy.updatedAt.lt,omitempty" json:"edge_followed_by_updated_at_lt,omitempty"`
	// Filters field "name" to be equal to the provided value.
	EdgeFollowedByNameEQ *string `form:"followedBy.name.eq,omitempty" json:"edge_followed_by_name_eq,omitempty"`
	// Filters field "name" to be not equal to the provided value.
	EdgeFollowedByNameNEQ *string `form:"followedBy.name.neq,omitempty" json:"edge_followed_by_name_neq,omitempty"`
	// Filters field "name" to be within the provided values.
	EdgeFollowedByNameIn []string `form:"followedBy.name.in,omitempty" json:"edge_followed_by_name_in,omitempty"`
	// Filters field "name" to be not within the provided values.
	EdgeFollowedByNameNotIn []string `form:"followedBy.name.notIn,omitempty" json:"edge_followed_by_name_not_in,omitempty"`
	// Filters field "name" to contain the provided value.
	EdgeFollowedByNameContains *string `form:"followedBy.name.has,omitempty" json:"edge_followed_by_name_contains,omitempty"`
	// Filters field "name" to start with the provided value.
	EdgeFollowedByNameHasPrefix *string `form:"followedBy.name.prefix,omitempty" json:"edge_followed_by_name_has_prefix,omitempty"`
	// Filters field "name" to end with the provided value.
	EdgeFollowedByNameHasSuffix *string `form:"followedBy.name.suffix,omitempty" json:"edge_followed_by_name_has_suffix,omitempty"`
	// Filters field "name" to be equal to the provided value, case-insensitive.
	EdgeFollowedByNameEqualFold *string `form:"followedBy.name.ieq,omitempty" json:"edge_followed_by_name_equal_fold,omitempty"`
	// Filters field "name" to contain the provided value, case-insensitive.
	EdgeFollowedByNameContainsFold *string `form:"followedBy.name.ihas,omitempty" json:"edge_followed_by_name_contains_fold,omitempty"`
	// Filters field "type" to be equal to the provided value.
	EdgeFollowedByTypeEQ *user.Type `form:"followedBy.type.eq,omitempty" json:"edge_followed_by_type_eq,omitempty"`
	// Filters field "type" to be not equal to the provided value.
	EdgeFollowedByTypeNEQ *user.Type `form:"followedBy.type.neq,omitempty" json:"edge_followed_by_type_neq,omitempty"`
	// Filters field "type" to be within the provided values.
	EdgeFollowedByTypeIn []user.Type `form:"followedBy.type.in,omitempty" json:"edge_followed_by_type_in,omitempty"`
	// Filters field "type" to be not within the provided values.
	EdgeFollowedByTypeNotIn []user.Type `form:"followedBy.type.notIn,omitempty" json:"edge_followed_by_type_not_in,omitempty"`
	// Filters field "description" to contain the provided value.
	EdgeFollowedByDescriptionContains *string `form:"followedBy.description.has,omitempty" json:"edge_followed_by_description_contains,omitempty"`
	// Filters field "description" to be null/nil.
	EdgeFollowedByDescriptionIsNil *bool `form:"followedBy.description.null,omitempty" json:"edge_followed_by_description_is_nil,omitempty"`
	// Filters field "description" to contain the provided value, case-insensitive.
	EdgeFollowedByDescriptionContainsFold *string `form:"followedBy.description.ihas,omitempty" json:"edge_followed_by_description_contains_fold,omitempty"`
	// Filters field "enabled" to be equal to the provided value.
	EdgeFollowedByEnabledEQ *bool `form:"followedBy.enabled.eq,omitempty" json:"edge_followed_by_enabled_eq,omitempty"`
	// Filters field "email" to be equal to the provided value.
	EdgeFollowedByEmailEQ *string `form:"followedBy.email.eq,omitempty" json:"edge_followed_by_email_eq,omitempty"`
	// Filters field "email" to be not equal to the provided value.
	EdgeFollowedByEmailNEQ *string `form:"followedBy.email.neq,omitempty" json:"edge_followed_by_email_neq,omitempty"`
	// Filters field "email" to be within the provided values.
	EdgeFollowedByEmailIn []string `form:"followedBy.email.in,omitempty" json:"edge_followed_by_email_in,omitempty"`
	// Filters field "email" to be not within the provided values.
	EdgeFollowedByEmailNotIn []string `form:"followedBy.email.notIn,omitempty" json:"edge_followed_by_email_not_in,omitempty"`
	// Filters field "email" to contain the provided value.
	EdgeFollowedByEmailContains *string `form:"followedBy.email.has,omitempty" json:"edge_followed_by_email_contains,omitempty"`
	// Filters field "email" to start with the provided value.
	EdgeFollowedByEmailHasPrefix *string `form:"followedBy.email.prefix,omitempty" json:"edge_followed_by_email_has_prefix,omitempty"`
	// Filters field "email" to end with the provided value.
	EdgeFollowedByEmailHasSuffix *string `form:"followedBy.email.suffix,omitempty" json:"edge_followed_by_email_has_suffix,omitempty"`
	// Filters field "email" to be null/nil.
	EdgeFollowedByEmailIsNil *bool `form:"followedBy.email.null,omitempty" json:"edge_followed_by_email_is_nil,omitempty"`
	// Filters field "email" to be equal to the provided value, case-insensitive.
	EdgeFollowedByEmailEqualFold *string `form:"followedBy.email.ieq,omitempty" json:"edge_followed_by_email_equal_fold,omitempty"`
	// Filters field "email" to contain the provided value, case-insensitive.
	EdgeFollowedByEmailContainsFold *string `form:"followedBy.email.ihas,omitempty" json:"edge_followed_by_email_contains_fold,omitempty"`
	// If true, only return entities that have a following edge.
	EdgeHasFollowing *bool `form:"has.following,omitempty" json:"edge_has_following,omitempty"`
}

// FilterPredicates returns the predicates for filter-related parameters in Pet.
func (l *ListPetParams) FilterPredicates() (predicate.Pet, error) {
	var predicates []predicate.Pet

	if l.PetNameEQ != nil {
		predicates = append(predicates, pet.NameEQ(*l.PetNameEQ))
	}
	if l.PetNameNEQ != nil {
		predicates = append(predicates, pet.NameNEQ(*l.PetNameNEQ))
	}
	if l.PetNameIn != nil {
		predicates = append(predicates, pet.NameIn(l.PetNameIn...))
	}
	if l.PetNameNotIn != nil {
		predicates = append(predicates, pet.NameNotIn(l.PetNameNotIn...))
	}
	if l.PetNameContains != nil {
		predicates = append(predicates, pet.NameContains(*l.PetNameContains))
	}
	if l.PetNameHasPrefix != nil {
		predicates = append(predicates, pet.NameHasPrefix(*l.PetNameHasPrefix))
	}
	if l.PetNameHasSuffix != nil {
		predicates = append(predicates, pet.NameHasSuffix(*l.PetNameHasSuffix))
	}
	if l.PetNameEqualFold != nil {
		predicates = append(predicates, pet.NameEqualFold(*l.PetNameEqualFold))
	}
	if l.PetNameContainsFold != nil {
		predicates = append(predicates, pet.NameContainsFold(*l.PetNameContainsFold))
	}
	if l.PetNicknamesIsNil != nil {
		if *l.PetNicknamesIsNil {
			predicates = append(predicates, pet.NicknamesIsNil())
		} else {
			predicates = append(predicates, pet.Not(pet.NicknamesIsNil()))
		}
	}
	if l.PetAgeEQ != nil {
		predicates = append(predicates, pet.AgeEQ(*l.PetAgeEQ))
	}
	if l.PetAgeNEQ != nil {
		predicates = append(predicates, pet.AgeNEQ(*l.PetAgeNEQ))
	}
	if l.PetAgeIn != nil {
		predicates = append(predicates, pet.AgeIn(l.PetAgeIn...))
	}
	if l.PetAgeNotIn != nil {
		predicates = append(predicates, pet.AgeNotIn(l.PetAgeNotIn...))
	}
	if l.PetAgeGT != nil {
		predicates = append(predicates, pet.AgeGT(*l.PetAgeGT))
	}
	if l.PetAgeLT != nil {
		predicates = append(predicates, pet.AgeLT(*l.PetAgeLT))
	}
	if l.PetAgeIsNil != nil {
		if *l.PetAgeIsNil {
			predicates = append(predicates, pet.AgeIsNil())
		} else {
			predicates = append(predicates, pet.Not(pet.AgeIsNil()))
		}
	}
	if l.EdgeHasCategory != nil {
		if *l.EdgeHasCategory {
			predicates = append(predicates, pet.HasCategories())
		} else {
			predicates = append(predicates, pet.Not(pet.HasCategories()))
		}
	}
	if l.EdgeCategoryCreatedAtGT != nil {
		predicates = append(predicates, pet.HasCategoriesWith(category.CreatedAtGT(*l.EdgeCategoryCreatedAtGT)))
	}
	if l.EdgeCategoryCreatedAtLT != nil {
		predicates = append(predicates, pet.HasCategoriesWith(category.CreatedAtLT(*l.EdgeCategoryCreatedAtLT)))
	}
	if l.EdgeCategoryUpdatedAtGT != nil {
		predicates = append(predicates, pet.HasCategoriesWith(category.UpdatedAtGT(*l.EdgeCategoryUpdatedAtGT)))
	}
	if l.EdgeCategoryUpdatedAtLT != nil {
		predicates = append(predicates, pet.HasCategoriesWith(category.UpdatedAtLT(*l.EdgeCategoryUpdatedAtLT)))
	}
	if l.EdgeHasOwner != nil {
		if *l.EdgeHasOwner {
			predicates = append(predicates, pet.HasOwner())
		} else {
			predicates = append(predicates, pet.Not(pet.HasOwner()))
		}
	}
	if l.EdgeOwnerCreatedAtGT != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.CreatedAtGT(*l.EdgeOwnerCreatedAtGT)))
	}
	if l.EdgeOwnerCreatedAtLT != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.CreatedAtLT(*l.EdgeOwnerCreatedAtLT)))
	}
	if l.EdgeOwnerUpdatedAtGT != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.UpdatedAtGT(*l.EdgeOwnerUpdatedAtGT)))
	}
	if l.EdgeOwnerUpdatedAtLT != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.UpdatedAtLT(*l.EdgeOwnerUpdatedAtLT)))
	}
	if l.EdgeOwnerNameEQ != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.NameEQ(*l.EdgeOwnerNameEQ)))
	}
	if l.EdgeOwnerNameNEQ != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.NameNEQ(*l.EdgeOwnerNameNEQ)))
	}
	if l.EdgeOwnerNameIn != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.NameIn(l.EdgeOwnerNameIn...)))
	}
	if l.EdgeOwnerNameNotIn != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.NameNotIn(l.EdgeOwnerNameNotIn...)))
	}
	if l.EdgeOwnerNameContains != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.NameContains(*l.EdgeOwnerNameContains)))
	}
	if l.EdgeOwnerNameHasPrefix != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.NameHasPrefix(*l.EdgeOwnerNameHasPrefix)))
	}
	if l.EdgeOwnerNameHasSuffix != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.NameHasSuffix(*l.EdgeOwnerNameHasSuffix)))
	}
	if l.EdgeOwnerNameEqualFold != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.NameEqualFold(*l.EdgeOwnerNameEqualFold)))
	}
	if l.EdgeOwnerNameContainsFold != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.NameContainsFold(*l.EdgeOwnerNameContainsFold)))
	}
	if l.EdgeOwnerTypeEQ != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.TypeEQ(*l.EdgeOwnerTypeEQ)))
	}
	if l.EdgeOwnerTypeNEQ != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.TypeNEQ(*l.EdgeOwnerTypeNEQ)))
	}
	if l.EdgeOwnerTypeIn != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.TypeIn(l.EdgeOwnerTypeIn...)))
	}
	if l.EdgeOwnerTypeNotIn != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.TypeNotIn(l.EdgeOwnerTypeNotIn...)))
	}
	if l.EdgeOwnerDescriptionContains != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.DescriptionContains(*l.EdgeOwnerDescriptionContains)))
	}
	if l.EdgeOwnerDescriptionIsNil != nil {
		if *l.EdgeOwnerDescriptionIsNil {
			predicates = append(predicates, pet.HasOwnerWith(user.DescriptionIsNil()))
		} else {
			predicates = append(predicates, pet.Not(pet.HasOwnerWith(user.DescriptionIsNil())))
		}
	}
	if l.EdgeOwnerDescriptionContainsFold != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.DescriptionContainsFold(*l.EdgeOwnerDescriptionContainsFold)))
	}
	if l.EdgeOwnerEnabledEQ != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.EnabledEQ(*l.EdgeOwnerEnabledEQ)))
	}
	if l.EdgeOwnerEmailEQ != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.EmailEQ(*l.EdgeOwnerEmailEQ)))
	}
	if l.EdgeOwnerEmailNEQ != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.EmailNEQ(*l.EdgeOwnerEmailNEQ)))
	}
	if l.EdgeOwnerEmailIn != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.EmailIn(l.EdgeOwnerEmailIn...)))
	}
	if l.EdgeOwnerEmailNotIn != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.EmailNotIn(l.EdgeOwnerEmailNotIn...)))
	}
	if l.EdgeOwnerEmailContains != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.EmailContains(*l.EdgeOwnerEmailContains)))
	}
	if l.EdgeOwnerEmailHasPrefix != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.EmailHasPrefix(*l.EdgeOwnerEmailHasPrefix)))
	}
	if l.EdgeOwnerEmailHasSuffix != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.EmailHasSuffix(*l.EdgeOwnerEmailHasSuffix)))
	}
	if l.EdgeOwnerEmailIsNil != nil {
		if *l.EdgeOwnerEmailIsNil {
			predicates = append(predicates, pet.HasOwnerWith(user.EmailIsNil()))
		} else {
			predicates = append(predicates, pet.Not(pet.HasOwnerWith(user.EmailIsNil())))
		}
	}
	if l.EdgeOwnerEmailEqualFold != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.EmailEqualFold(*l.EdgeOwnerEmailEqualFold)))
	}
	if l.EdgeOwnerEmailContainsFold != nil {
		predicates = append(predicates, pet.HasOwnerWith(user.EmailContainsFold(*l.EdgeOwnerEmailContainsFold)))
	}
	if l.EdgeHasFriend != nil {
		if *l.EdgeHasFriend {
			predicates = append(predicates, pet.HasFriends())
		} else {
			predicates = append(predicates, pet.Not(pet.HasFriends()))
		}
	}
	if l.EdgeFriendNameEQ != nil {
		predicates = append(predicates, pet.HasFriendsWith(pet.NameEQ(*l.EdgeFriendNameEQ)))
	}
	if l.EdgeFriendNameNEQ != nil {
		predicates = append(predicates, pet.HasFriendsWith(pet.NameNEQ(*l.EdgeFriendNameNEQ)))
	}
	if l.EdgeFriendNameIn != nil {
		predicates = append(predicates, pet.HasFriendsWith(pet.NameIn(l.EdgeFriendNameIn...)))
	}
	if l.EdgeFriendNameNotIn != nil {
		predicates = append(predicates, pet.HasFriendsWith(pet.NameNotIn(l.EdgeFriendNameNotIn...)))
	}
	if l.EdgeFriendNameContains != nil {
		predicates = append(predicates, pet.HasFriendsWith(pet.NameContains(*l.EdgeFriendNameContains)))
	}
	if l.EdgeFriendNameHasPrefix != nil {
		predicates = append(predicates, pet.HasFriendsWith(pet.NameHasPrefix(*l.EdgeFriendNameHasPrefix)))
	}
	if l.EdgeFriendNameHasSuffix != nil {
		predicates = append(predicates, pet.HasFriendsWith(pet.NameHasSuffix(*l.EdgeFriendNameHasSuffix)))
	}
	if l.EdgeFriendNameEqualFold != nil {
		predicates = append(predicates, pet.HasFriendsWith(pet.NameEqualFold(*l.EdgeFriendNameEqualFold)))
	}
	if l.EdgeFriendNameContainsFold != nil {
		predicates = append(predicates, pet.HasFriendsWith(pet.NameContainsFold(*l.EdgeFriendNameContainsFold)))
	}
	if l.EdgeFriendNicknamesIsNil != nil {
		if *l.EdgeFriendNicknamesIsNil {
			predicates = append(predicates, pet.HasFriendsWith(pet.NicknamesIsNil()))
		} else {
			predicates = append(predicates, pet.Not(pet.HasFriendsWith(pet.NicknamesIsNil())))
		}
	}
	if l.EdgeFriendAgeEQ != nil {
		predicates = append(predicates, pet.HasFriendsWith(pet.AgeEQ(*l.EdgeFriendAgeEQ)))
	}
	if l.EdgeFriendAgeNEQ != nil {
		predicates = append(predicates, pet.HasFriendsWith(pet.AgeNEQ(*l.EdgeFriendAgeNEQ)))
	}
	if l.EdgeFriendAgeIn != nil {
		predicates = append(predicates, pet.HasFriendsWith(pet.AgeIn(l.EdgeFriendAgeIn...)))
	}
	if l.EdgeFriendAgeNotIn != nil {
		predicates = append(predicates, pet.HasFriendsWith(pet.AgeNotIn(l.EdgeFriendAgeNotIn...)))
	}
	if l.EdgeFriendAgeGT != nil {
		predicates = append(predicates, pet.HasFriendsWith(pet.AgeGT(*l.EdgeFriendAgeGT)))
	}
	if l.EdgeFriendAgeLT != nil {
		predicates = append(predicates, pet.HasFriendsWith(pet.AgeLT(*l.EdgeFriendAgeLT)))
	}
	if l.EdgeFriendAgeIsNil != nil {
		if *l.EdgeFriendAgeIsNil {
			predicates = append(predicates, pet.HasFriendsWith(pet.AgeIsNil()))
		} else {
			predicates = append(predicates, pet.Not(pet.HasFriendsWith(pet.AgeIsNil())))
		}
	}
	if l.EdgeHasFollowedBy != nil {
		if *l.EdgeHasFollowedBy {
			predicates = append(predicates, pet.HasFollowedBy())
		} else {
			predicates = append(predicates, pet.Not(pet.HasFollowedBy()))
		}
	}
	if l.EdgeFollowedByCreatedAtGT != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.CreatedAtGT(*l.EdgeFollowedByCreatedAtGT)))
	}
	if l.EdgeFollowedByCreatedAtLT != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.CreatedAtLT(*l.EdgeFollowedByCreatedAtLT)))
	}
	if l.EdgeFollowedByUpdatedAtGT != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.UpdatedAtGT(*l.EdgeFollowedByUpdatedAtGT)))
	}
	if l.EdgeFollowedByUpdatedAtLT != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.UpdatedAtLT(*l.EdgeFollowedByUpdatedAtLT)))
	}
	if l.EdgeFollowedByNameEQ != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.NameEQ(*l.EdgeFollowedByNameEQ)))
	}
	if l.EdgeFollowedByNameNEQ != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.NameNEQ(*l.EdgeFollowedByNameNEQ)))
	}
	if l.EdgeFollowedByNameIn != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.NameIn(l.EdgeFollowedByNameIn...)))
	}
	if l.EdgeFollowedByNameNotIn != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.NameNotIn(l.EdgeFollowedByNameNotIn...)))
	}
	if l.EdgeFollowedByNameContains != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.NameContains(*l.EdgeFollowedByNameContains)))
	}
	if l.EdgeFollowedByNameHasPrefix != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.NameHasPrefix(*l.EdgeFollowedByNameHasPrefix)))
	}
	if l.EdgeFollowedByNameHasSuffix != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.NameHasSuffix(*l.EdgeFollowedByNameHasSuffix)))
	}
	if l.EdgeFollowedByNameEqualFold != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.NameEqualFold(*l.EdgeFollowedByNameEqualFold)))
	}
	if l.EdgeFollowedByNameContainsFold != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.NameContainsFold(*l.EdgeFollowedByNameContainsFold)))
	}
	if l.EdgeFollowedByTypeEQ != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.TypeEQ(*l.EdgeFollowedByTypeEQ)))
	}
	if l.EdgeFollowedByTypeNEQ != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.TypeNEQ(*l.EdgeFollowedByTypeNEQ)))
	}
	if l.EdgeFollowedByTypeIn != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.TypeIn(l.EdgeFollowedByTypeIn...)))
	}
	if l.EdgeFollowedByTypeNotIn != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.TypeNotIn(l.EdgeFollowedByTypeNotIn...)))
	}
	if l.EdgeFollowedByDescriptionContains != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.DescriptionContains(*l.EdgeFollowedByDescriptionContains)))
	}
	if l.EdgeFollowedByDescriptionIsNil != nil {
		if *l.EdgeFollowedByDescriptionIsNil {
			predicates = append(predicates, pet.HasFollowedByWith(user.DescriptionIsNil()))
		} else {
			predicates = append(predicates, pet.Not(pet.HasFollowedByWith(user.DescriptionIsNil())))
		}
	}
	if l.EdgeFollowedByDescriptionContainsFold != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.DescriptionContainsFold(*l.EdgeFollowedByDescriptionContainsFold)))
	}
	if l.EdgeFollowedByEnabledEQ != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.EnabledEQ(*l.EdgeFollowedByEnabledEQ)))
	}
	if l.EdgeFollowedByEmailEQ != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.EmailEQ(*l.EdgeFollowedByEmailEQ)))
	}
	if l.EdgeFollowedByEmailNEQ != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.EmailNEQ(*l.EdgeFollowedByEmailNEQ)))
	}
	if l.EdgeFollowedByEmailIn != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.EmailIn(l.EdgeFollowedByEmailIn...)))
	}
	if l.EdgeFollowedByEmailNotIn != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.EmailNotIn(l.EdgeFollowedByEmailNotIn...)))
	}
	if l.EdgeFollowedByEmailContains != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.EmailContains(*l.EdgeFollowedByEmailContains)))
	}
	if l.EdgeFollowedByEmailHasPrefix != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.EmailHasPrefix(*l.EdgeFollowedByEmailHasPrefix)))
	}
	if l.EdgeFollowedByEmailHasSuffix != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.EmailHasSuffix(*l.EdgeFollowedByEmailHasSuffix)))
	}
	if l.EdgeFollowedByEmailIsNil != nil {
		if *l.EdgeFollowedByEmailIsNil {
			predicates = append(predicates, pet.HasFollowedByWith(user.EmailIsNil()))
		} else {
			predicates = append(predicates, pet.Not(pet.HasFollowedByWith(user.EmailIsNil())))
		}
	}
	if l.EdgeFollowedByEmailEqualFold != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.EmailEqualFold(*l.EdgeFollowedByEmailEqualFold)))
	}
	if l.EdgeFollowedByEmailContainsFold != nil {
		predicates = append(predicates, pet.HasFollowedByWith(user.EmailContainsFold(*l.EdgeFollowedByEmailContainsFold)))
	}
	if l.EdgeHasFollowing != nil {
		if *l.EdgeHasFollowing {
			predicates = append(predicates, pet.HasFollowing())
		} else {
			predicates = append(predicates, pet.Not(pet.HasFollowing()))
		}
	}
	return l.ApplyFilterOperation(predicates...)
}

// ApplySorting applies sorting to the query based on the provided sort and order fields.
func (l *ListPetParams) ApplySorting(query *ent.PetQuery) (*ent.PetQuery, error) {
	if l.Sort == nil {
		return query, nil
	}
	if err := l.Sorted.Validate(PetSortFields); err != nil {
		return nil, err
	}
	if parts := strings.Split(*l.Sort, "."); len(parts) > 1 {
		dir := l.Sorted.SortOrderTerm()

		var isCount, isSum bool
		if len(parts) > 2 {
			switch parts[2] {
			case "count":
				isCount = true
			case "sum":
				isSum = true
			}
		}

		switch parts[0] {
		case pet.EdgeCategories:
			switch {
			case isCount:
				return query.Order(pet.ByCategoriesCount(dir)), nil
			case isSum:
				return query.Order(pet.ByCategories(sql.OrderBySum(parts[1], dir))), nil
			default:
				return query.Order(pet.ByCategories(sql.OrderByField(parts[1], dir))), nil
			}
		case pet.EdgeOwner:
			return query.Order(pet.ByOwnerField(parts[1], dir)), nil
		case pet.EdgeFriends:
			switch {
			case isCount:
				return query.Order(pet.ByFriendsCount(dir)), nil
			case isSum:
				return query.Order(pet.ByFriends(sql.OrderBySum(parts[1], dir))), nil
			default:
				return query.Order(pet.ByFriends(sql.OrderByField(parts[1], dir))), nil
			}
		case pet.EdgeFollowedBy:
			switch {
			case isCount:
				return query.Order(pet.ByFollowedByCount(dir)), nil
			case isSum:
				return query.Order(pet.ByFollowedBy(sql.OrderBySum(parts[1], dir))), nil
			default:
				return query.Order(pet.ByFollowedBy(sql.OrderByField(parts[1], dir))), nil
			}
		case pet.EdgeFollowing:
			switch {
			case isCount:
				return query.Order(pet.ByFollowingCount(dir)), nil
			case isSum:
				return query.Order(pet.ByFollowing(sql.OrderBySum(parts[1], dir))), nil
			default:
				return query.Order(pet.ByFollowing(sql.OrderByField(parts[1], dir))), nil
			}
		}
	}
	if *l.Sort == "random" {
		return query.Order(sql.OrderByRand()), nil
	}
	return query.Order(l.Sorted.SortFieldSelector()), nil
}

// Exec wraps all logic (filtering, sorting, pagination, eager loading) and
// executes all necessary queries, returning the results.
func (l *ListPetParams) Exec(ctx context.Context, query *ent.PetQuery) (results *PagedResponse[ent.Pet], err error) {
	predicates, err := l.FilterPredicates()
	if err != nil {
		return nil, err
	}
	query = query.Where(predicates)
	query, err = l.ApplySorting(EagerLoadPet(query))
	if err != nil {
		return nil, err
	}
	return l.ExecutePaginated(ctx, query, PetPageConfig)
}

// ListSettingParams defines parameters for listing Settings via a GET request.
type ListSettingParams struct {
	Sorted
	Paginated[*ent.SettingsQuery, ent.Settings]
	Filtered[predicate.Settings]

	// Filters field "created_at" to be greater than the provided value.
	SettingsCreatedAtGT *time.Time `form:"createdAt.gt,omitempty" json:"settings_created_at_gt,omitempty"`
	// Filters field "created_at" to be less than the provided value.
	SettingsCreatedAtLT *time.Time `form:"createdAt.lt,omitempty" json:"settings_created_at_lt,omitempty"`
	// Filters field "updated_at" to be greater than the provided value.
	SettingsUpdatedAtGT *time.Time `form:"updatedAt.gt,omitempty" json:"settings_updated_at_gt,omitempty"`
	// Filters field "updated_at" to be less than the provided value.
	SettingsUpdatedAtLT *time.Time `form:"updatedAt.lt,omitempty" json:"settings_updated_at_lt,omitempty"`
}

// FilterPredicates returns the predicates for filter-related parameters in Setting.
func (l *ListSettingParams) FilterPredicates() (predicate.Settings, error) {
	var predicates []predicate.Settings

	if l.SettingsCreatedAtGT != nil {
		predicates = append(predicates, settings.CreatedAtGT(*l.SettingsCreatedAtGT))
	}
	if l.SettingsCreatedAtLT != nil {
		predicates = append(predicates, settings.CreatedAtLT(*l.SettingsCreatedAtLT))
	}
	if l.SettingsUpdatedAtGT != nil {
		predicates = append(predicates, settings.UpdatedAtGT(*l.SettingsUpdatedAtGT))
	}
	if l.SettingsUpdatedAtLT != nil {
		predicates = append(predicates, settings.UpdatedAtLT(*l.SettingsUpdatedAtLT))
	}
	return l.ApplyFilterOperation(predicates...)
}

// ApplySorting applies sorting to the query based on the provided sort and order fields.
func (l *ListSettingParams) ApplySorting(query *ent.SettingsQuery) (*ent.SettingsQuery, error) {
	if l.Sort == nil {
		return query, nil
	}
	if err := l.Sorted.Validate(SettingSortFields); err != nil {
		return nil, err
	}
	if parts := strings.Split(*l.Sort, "."); len(parts) > 1 {
		dir := l.Sorted.SortOrderTerm()

		var isCount, isSum bool
		if len(parts) > 2 {
			switch parts[2] {
			case "count":
				isCount = true
			case "sum":
				isSum = true
			}
		}

		switch parts[0] {
		case settings.EdgeAdmins:
			switch {
			case isCount:
				return query.Order(settings.ByAdminsCount(dir)), nil
			case isSum:
				return query.Order(settings.ByAdmins(sql.OrderBySum(parts[1], dir))), nil
			default:
				return query.Order(settings.ByAdmins(sql.OrderByField(parts[1], dir))), nil
			}
		}
	}
	if *l.Sort == "random" {
		return query.Order(sql.OrderByRand()), nil
	}
	return query.Order(l.Sorted.SortFieldSelector()), nil
}

// Exec wraps all logic (filtering, sorting, pagination, eager loading) and
// executes all necessary queries, returning the results.
func (l *ListSettingParams) Exec(ctx context.Context, query *ent.SettingsQuery) (results *PagedResponse[ent.Settings], err error) {
	predicates, err := l.FilterPredicates()
	if err != nil {
		return nil, err
	}
	query = query.Where(predicates)
	query, err = l.ApplySorting(EagerLoadSetting(query))
	if err != nil {
		return nil, err
	}
	return l.ExecutePaginated(ctx, query, SettingPageConfig)
}

// ListUserParams defines parameters for listing Users via a GET request.
type ListUserParams struct {
	Sorted
	Paginated[*ent.UserQuery, ent.User]
	Filtered[predicate.User]

	// Filters field "created_at" to be greater than the provided value.
	UserCreatedAtGT *time.Time `form:"createdAt.gt,omitempty" json:"user_created_at_gt,omitempty"`
	// Filters field "created_at" to be less than the provided value.
	UserCreatedAtLT *time.Time `form:"createdAt.lt,omitempty" json:"user_created_at_lt,omitempty"`
	// Filters field "updated_at" to be greater than the provided value.
	UserUpdatedAtGT *time.Time `form:"updatedAt.gt,omitempty" json:"user_updated_at_gt,omitempty"`
	// Filters field "updated_at" to be less than the provided value.
	UserUpdatedAtLT *time.Time `form:"updatedAt.lt,omitempty" json:"user_updated_at_lt,omitempty"`
	// Filters field "name" to be equal to the provided value.
	UserNameEQ *string `form:"name.eq,omitempty" json:"user_name_eq,omitempty"`
	// Filters field "name" to be not equal to the provided value.
	UserNameNEQ *string `form:"name.neq,omitempty" json:"user_name_neq,omitempty"`
	// Filters field "name" to be within the provided values.
	UserNameIn []string `form:"name.in,omitempty" json:"user_name_in,omitempty"`
	// Filters field "name" to be not within the provided values.
	UserNameNotIn []string `form:"name.notIn,omitempty" json:"user_name_not_in,omitempty"`
	// Filters field "name" to contain the provided value.
	UserNameContains *string `form:"name.has,omitempty" json:"user_name_contains,omitempty"`
	// Filters field "name" to start with the provided value.
	UserNameHasPrefix *string `form:"name.prefix,omitempty" json:"user_name_has_prefix,omitempty"`
	// Filters field "name" to end with the provided value.
	UserNameHasSuffix *string `form:"name.suffix,omitempty" json:"user_name_has_suffix,omitempty"`
	// Filters field "name" to be equal to the provided value, case-insensitive.
	UserNameEqualFold *string `form:"name.ieq,omitempty" json:"user_name_equal_fold,omitempty"`
	// Filters field "name" to contain the provided value, case-insensitive.
	UserNameContainsFold *string `form:"name.ihas,omitempty" json:"user_name_contains_fold,omitempty"`
	// Filters field "type" to be equal to the provided value.
	UserTypeEQ *user.Type `form:"type.eq,omitempty" json:"user_type_eq,omitempty"`
	// Filters field "type" to be not equal to the provided value.
	UserTypeNEQ *user.Type `form:"type.neq,omitempty" json:"user_type_neq,omitempty"`
	// Filters field "type" to be within the provided values.
	UserTypeIn []user.Type `form:"type.in,omitempty" json:"user_type_in,omitempty"`
	// Filters field "type" to be not within the provided values.
	UserTypeNotIn []user.Type `form:"type.notIn,omitempty" json:"user_type_not_in,omitempty"`
	// Filters field "description" to contain the provided value.
	UserDescriptionContains *string `form:"description.has,omitempty" json:"user_description_contains,omitempty"`
	// Filters field "description" to be null/nil.
	UserDescriptionIsNil *bool `form:"description.null,omitempty" json:"user_description_is_nil,omitempty"`
	// Filters field "description" to contain the provided value, case-insensitive.
	UserDescriptionContainsFold *string `form:"description.ihas,omitempty" json:"user_description_contains_fold,omitempty"`
	// Filters field "enabled" to be equal to the provided value.
	UserEnabledEQ *bool `form:"enabled.eq,omitempty" json:"user_enabled_eq,omitempty"`
	// Filters field "email" to be equal to the provided value.
	UserEmailEQ *string `form:"email.eq,omitempty" json:"user_email_eq,omitempty"`
	// Filters field "email" to be not equal to the provided value.
	UserEmailNEQ *string `form:"email.neq,omitempty" json:"user_email_neq,omitempty"`
	// Filters field "email" to be within the provided values.
	UserEmailIn []string `form:"email.in,omitempty" json:"user_email_in,omitempty"`
	// Filters field "email" to be not within the provided values.
	UserEmailNotIn []string `form:"email.notIn,omitempty" json:"user_email_not_in,omitempty"`
	// Filters field "email" to contain the provided value.
	UserEmailContains *string `form:"email.has,omitempty" json:"user_email_contains,omitempty"`
	// Filters field "email" to start with the provided value.
	UserEmailHasPrefix *string `form:"email.prefix,omitempty" json:"user_email_has_prefix,omitempty"`
	// Filters field "email" to end with the provided value.
	UserEmailHasSuffix *string `form:"email.suffix,omitempty" json:"user_email_has_suffix,omitempty"`
	// Filters field "email" to be null/nil.
	UserEmailIsNil *bool `form:"email.null,omitempty" json:"user_email_is_nil,omitempty"`
	// Filters field "email" to be equal to the provided value, case-insensitive.
	UserEmailEqualFold *string `form:"email.ieq,omitempty" json:"user_email_equal_fold,omitempty"`
	// Filters field "email" to contain the provided value, case-insensitive.
	UserEmailContainsFold *string `form:"email.ihas,omitempty" json:"user_email_contains_fold,omitempty"`
	// If true, only return entities that have a pet edge.
	EdgeHasPet *bool `form:"has.pet,omitempty" json:"edge_has_pet,omitempty"`
	// Filters field "name" to be equal to the provided value.
	EdgePetNameEQ *string `form:"pet.name.eq,omitempty" json:"edge_pet_name_eq,omitempty"`
	// Filters field "name" to be not equal to the provided value.
	EdgePetNameNEQ *string `form:"pet.name.neq,omitempty" json:"edge_pet_name_neq,omitempty"`
	// Filters field "name" to be within the provided values.
	EdgePetNameIn []string `form:"pet.name.in,omitempty" json:"edge_pet_name_in,omitempty"`
	// Filters field "name" to be not within the provided values.
	EdgePetNameNotIn []string `form:"pet.name.notIn,omitempty" json:"edge_pet_name_not_in,omitempty"`
	// Filters field "name" to contain the provided value.
	EdgePetNameContains *string `form:"pet.name.has,omitempty" json:"edge_pet_name_contains,omitempty"`
	// Filters field "name" to start with the provided value.
	EdgePetNameHasPrefix *string `form:"pet.name.prefix,omitempty" json:"edge_pet_name_has_prefix,omitempty"`
	// Filters field "name" to end with the provided value.
	EdgePetNameHasSuffix *string `form:"pet.name.suffix,omitempty" json:"edge_pet_name_has_suffix,omitempty"`
	// Filters field "name" to be equal to the provided value, case-insensitive.
	EdgePetNameEqualFold *string `form:"pet.name.ieq,omitempty" json:"edge_pet_name_equal_fold,omitempty"`
	// Filters field "name" to contain the provided value, case-insensitive.
	EdgePetNameContainsFold *string `form:"pet.name.ihas,omitempty" json:"edge_pet_name_contains_fold,omitempty"`
	// Filters field "nicknames" to be null/nil.
	EdgePetNicknamesIsNil *bool `form:"pet.nicknames.null,omitempty" json:"edge_pet_nicknames_is_nil,omitempty"`
	// Filters field "age" to be equal to the provided value.
	EdgePetAgeEQ *int `form:"pet.age.eq,omitempty" json:"edge_pet_age_eq,omitempty"`
	// Filters field "age" to be not equal to the provided value.
	EdgePetAgeNEQ *int `form:"pet.age.neq,omitempty" json:"edge_pet_age_neq,omitempty"`
	// Filters field "age" to be within the provided values.
	EdgePetAgeIn []int `form:"pet.age.in,omitempty" json:"edge_pet_age_in,omitempty"`
	// Filters field "age" to be not within the provided values.
	EdgePetAgeNotIn []int `form:"pet.age.notIn,omitempty" json:"edge_pet_age_not_in,omitempty"`
	// Filters field "age" to be greater than the provided value.
	EdgePetAgeGT *int `form:"pet.age.gt,omitempty" json:"edge_pet_age_gt,omitempty"`
	// Filters field "age" to be less than the provided value.
	EdgePetAgeLT *int `form:"pet.age.lt,omitempty" json:"edge_pet_age_lt,omitempty"`
	// Filters field "age" to be null/nil.
	EdgePetAgeIsNil *bool `form:"pet.age.null,omitempty" json:"edge_pet_age_is_nil,omitempty"`
	// If true, only return entities that have a followed_pet edge.
	EdgeHasFollowedPet *bool `form:"has.followedPet,omitempty" json:"edge_has_followed_pet,omitempty"`
	// Filters field "name" to be equal to the provided value.
	EdgeFollowedPetNameEQ *string `form:"followedPet.name.eq,omitempty" json:"edge_followed_pet_name_eq,omitempty"`
	// Filters field "name" to be not equal to the provided value.
	EdgeFollowedPetNameNEQ *string `form:"followedPet.name.neq,omitempty" json:"edge_followed_pet_name_neq,omitempty"`
	// Filters field "name" to be within the provided values.
	EdgeFollowedPetNameIn []string `form:"followedPet.name.in,omitempty" json:"edge_followed_pet_name_in,omitempty"`
	// Filters field "name" to be not within the provided values.
	EdgeFollowedPetNameNotIn []string `form:"followedPet.name.notIn,omitempty" json:"edge_followed_pet_name_not_in,omitempty"`
	// Filters field "name" to contain the provided value.
	EdgeFollowedPetNameContains *string `form:"followedPet.name.has,omitempty" json:"edge_followed_pet_name_contains,omitempty"`
	// Filters field "name" to start with the provided value.
	EdgeFollowedPetNameHasPrefix *string `form:"followedPet.name.prefix,omitempty" json:"edge_followed_pet_name_has_prefix,omitempty"`
	// Filters field "name" to end with the provided value.
	EdgeFollowedPetNameHasSuffix *string `form:"followedPet.name.suffix,omitempty" json:"edge_followed_pet_name_has_suffix,omitempty"`
	// Filters field "name" to be equal to the provided value, case-insensitive.
	EdgeFollowedPetNameEqualFold *string `form:"followedPet.name.ieq,omitempty" json:"edge_followed_pet_name_equal_fold,omitempty"`
	// Filters field "name" to contain the provided value, case-insensitive.
	EdgeFollowedPetNameContainsFold *string `form:"followedPet.name.ihas,omitempty" json:"edge_followed_pet_name_contains_fold,omitempty"`
	// Filters field "nicknames" to be null/nil.
	EdgeFollowedPetNicknamesIsNil *bool `form:"followedPet.nicknames.null,omitempty" json:"edge_followed_pet_nicknames_is_nil,omitempty"`
	// Filters field "age" to be equal to the provided value.
	EdgeFollowedPetAgeEQ *int `form:"followedPet.age.eq,omitempty" json:"edge_followed_pet_age_eq,omitempty"`
	// Filters field "age" to be not equal to the provided value.
	EdgeFollowedPetAgeNEQ *int `form:"followedPet.age.neq,omitempty" json:"edge_followed_pet_age_neq,omitempty"`
	// Filters field "age" to be within the provided values.
	EdgeFollowedPetAgeIn []int `form:"followedPet.age.in,omitempty" json:"edge_followed_pet_age_in,omitempty"`
	// Filters field "age" to be not within the provided values.
	EdgeFollowedPetAgeNotIn []int `form:"followedPet.age.notIn,omitempty" json:"edge_followed_pet_age_not_in,omitempty"`
	// Filters field "age" to be greater than the provided value.
	EdgeFollowedPetAgeGT *int `form:"followedPet.age.gt,omitempty" json:"edge_followed_pet_age_gt,omitempty"`
	// Filters field "age" to be less than the provided value.
	EdgeFollowedPetAgeLT *int `form:"followedPet.age.lt,omitempty" json:"edge_followed_pet_age_lt,omitempty"`
	// Filters field "age" to be null/nil.
	EdgeFollowedPetAgeIsNil *bool `form:"followedPet.age.null,omitempty" json:"edge_followed_pet_age_is_nil,omitempty"`
	// If true, only return entities that have a friend edge.
	EdgeHasFriend *bool `form:"has.friend,omitempty" json:"edge_has_friend,omitempty"`
	// Filters field "created_at" to be greater than the provided value.
	EdgeFriendCreatedAtGT *time.Time `form:"friend.createdAt.gt,omitempty" json:"edge_friend_created_at_gt,omitempty"`
	// Filters field "created_at" to be less than the provided value.
	EdgeFriendCreatedAtLT *time.Time `form:"friend.createdAt.lt,omitempty" json:"edge_friend_created_at_lt,omitempty"`
	// Filters field "updated_at" to be greater than the provided value.
	EdgeFriendUpdatedAtGT *time.Time `form:"friend.updatedAt.gt,omitempty" json:"edge_friend_updated_at_gt,omitempty"`
	// Filters field "updated_at" to be less than the provided value.
	EdgeFriendUpdatedAtLT *time.Time `form:"friend.updatedAt.lt,omitempty" json:"edge_friend_updated_at_lt,omitempty"`
	// Filters field "name" to be equal to the provided value.
	EdgeFriendNameEQ *string `form:"friend.name.eq,omitempty" json:"edge_friend_name_eq,omitempty"`
	// Filters field "name" to be not equal to the provided value.
	EdgeFriendNameNEQ *string `form:"friend.name.neq,omitempty" json:"edge_friend_name_neq,omitempty"`
	// Filters field "name" to be within the provided values.
	EdgeFriendNameIn []string `form:"friend.name.in,omitempty" json:"edge_friend_name_in,omitempty"`
	// Filters field "name" to be not within the provided values.
	EdgeFriendNameNotIn []string `form:"friend.name.notIn,omitempty" json:"edge_friend_name_not_in,omitempty"`
	// Filters field "name" to contain the provided value.
	EdgeFriendNameContains *string `form:"friend.name.has,omitempty" json:"edge_friend_name_contains,omitempty"`
	// Filters field "name" to start with the provided value.
	EdgeFriendNameHasPrefix *string `form:"friend.name.prefix,omitempty" json:"edge_friend_name_has_prefix,omitempty"`
	// Filters field "name" to end with the provided value.
	EdgeFriendNameHasSuffix *string `form:"friend.name.suffix,omitempty" json:"edge_friend_name_has_suffix,omitempty"`
	// Filters field "name" to be equal to the provided value, case-insensitive.
	EdgeFriendNameEqualFold *string `form:"friend.name.ieq,omitempty" json:"edge_friend_name_equal_fold,omitempty"`
	// Filters field "name" to contain the provided value, case-insensitive.
	EdgeFriendNameContainsFold *string `form:"friend.name.ihas,omitempty" json:"edge_friend_name_contains_fold,omitempty"`
	// Filters field "type" to be equal to the provided value.
	EdgeFriendTypeEQ *user.Type `form:"friend.type.eq,omitempty" json:"edge_friend_type_eq,omitempty"`
	// Filters field "type" to be not equal to the provided value.
	EdgeFriendTypeNEQ *user.Type `form:"friend.type.neq,omitempty" json:"edge_friend_type_neq,omitempty"`
	// Filters field "type" to be within the provided values.
	EdgeFriendTypeIn []user.Type `form:"friend.type.in,omitempty" json:"edge_friend_type_in,omitempty"`
	// Filters field "type" to be not within the provided values.
	EdgeFriendTypeNotIn []user.Type `form:"friend.type.notIn,omitempty" json:"edge_friend_type_not_in,omitempty"`
	// Filters field "description" to contain the provided value.
	EdgeFriendDescriptionContains *string `form:"friend.description.has,omitempty" json:"edge_friend_description_contains,omitempty"`
	// Filters field "description" to be null/nil.
	EdgeFriendDescriptionIsNil *bool `form:"friend.description.null,omitempty" json:"edge_friend_description_is_nil,omitempty"`
	// Filters field "description" to contain the provided value, case-insensitive.
	EdgeFriendDescriptionContainsFold *string `form:"friend.description.ihas,omitempty" json:"edge_friend_description_contains_fold,omitempty"`
	// Filters field "enabled" to be equal to the provided value.
	EdgeFriendEnabledEQ *bool `form:"friend.enabled.eq,omitempty" json:"edge_friend_enabled_eq,omitempty"`
	// Filters field "email" to be equal to the provided value.
	EdgeFriendEmailEQ *string `form:"friend.email.eq,omitempty" json:"edge_friend_email_eq,omitempty"`
	// Filters field "email" to be not equal to the provided value.
	EdgeFriendEmailNEQ *string `form:"friend.email.neq,omitempty" json:"edge_friend_email_neq,omitempty"`
	// Filters field "email" to be within the provided values.
	EdgeFriendEmailIn []string `form:"friend.email.in,omitempty" json:"edge_friend_email_in,omitempty"`
	// Filters field "email" to be not within the provided values.
	EdgeFriendEmailNotIn []string `form:"friend.email.notIn,omitempty" json:"edge_friend_email_not_in,omitempty"`
	// Filters field "email" to contain the provided value.
	EdgeFriendEmailContains *string `form:"friend.email.has,omitempty" json:"edge_friend_email_contains,omitempty"`
	// Filters field "email" to start with the provided value.
	EdgeFriendEmailHasPrefix *string `form:"friend.email.prefix,omitempty" json:"edge_friend_email_has_prefix,omitempty"`
	// Filters field "email" to end with the provided value.
	EdgeFriendEmailHasSuffix *string `form:"friend.email.suffix,omitempty" json:"edge_friend_email_has_suffix,omitempty"`
	// Filters field "email" to be null/nil.
	EdgeFriendEmailIsNil *bool `form:"friend.email.null,omitempty" json:"edge_friend_email_is_nil,omitempty"`
	// Filters field "email" to be equal to the provided value, case-insensitive.
	EdgeFriendEmailEqualFold *string `form:"friend.email.ieq,omitempty" json:"edge_friend_email_equal_fold,omitempty"`
	// Filters field "email" to contain the provided value, case-insensitive.
	EdgeFriendEmailContainsFold *string `form:"friend.email.ihas,omitempty" json:"edge_friend_email_contains_fold,omitempty"`
	// If true, only return entities that have a following edge.
	EdgeHasFollowing *bool `form:"has.following,omitempty" json:"edge_has_following,omitempty"`
	// If true, only return entities that have a friendship edge.
	EdgeHasFriendship *bool `form:"has.friendship,omitempty" json:"edge_has_friendship,omitempty"`
}

// FilterPredicates returns the predicates for filter-related parameters in User.
func (l *ListUserParams) FilterPredicates() (predicate.User, error) {
	var predicates []predicate.User

	if l.UserCreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*l.UserCreatedAtGT))
	}
	if l.UserCreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*l.UserCreatedAtLT))
	}
	if l.UserUpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*l.UserUpdatedAtGT))
	}
	if l.UserUpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*l.UserUpdatedAtLT))
	}
	if l.UserNameEQ != nil {
		predicates = append(predicates, user.NameEQ(*l.UserNameEQ))
	}
	if l.UserNameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*l.UserNameNEQ))
	}
	if l.UserNameIn != nil {
		predicates = append(predicates, user.NameIn(l.UserNameIn...))
	}
	if l.UserNameNotIn != nil {
		predicates = append(predicates, user.NameNotIn(l.UserNameNotIn...))
	}
	if l.UserNameContains != nil {
		predicates = append(predicates, user.NameContains(*l.UserNameContains))
	}
	if l.UserNameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*l.UserNameHasPrefix))
	}
	if l.UserNameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*l.UserNameHasSuffix))
	}
	if l.UserNameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*l.UserNameEqualFold))
	}
	if l.UserNameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*l.UserNameContainsFold))
	}
	if l.UserTypeEQ != nil {
		predicates = append(predicates, user.TypeEQ(*l.UserTypeEQ))
	}
	if l.UserTypeNEQ != nil {
		predicates = append(predicates, user.TypeNEQ(*l.UserTypeNEQ))
	}
	if l.UserTypeIn != nil {
		predicates = append(predicates, user.TypeIn(l.UserTypeIn...))
	}
	if l.UserTypeNotIn != nil {
		predicates = append(predicates, user.TypeNotIn(l.UserTypeNotIn...))
	}
	if l.UserDescriptionContains != nil {
		predicates = append(predicates, user.DescriptionContains(*l.UserDescriptionContains))
	}
	if l.UserDescriptionIsNil != nil {
		if *l.UserDescriptionIsNil {
			predicates = append(predicates, user.DescriptionIsNil())
		} else {
			predicates = append(predicates, user.Not(user.DescriptionIsNil()))
		}
	}
	if l.UserDescriptionContainsFold != nil {
		predicates = append(predicates, user.DescriptionContainsFold(*l.UserDescriptionContainsFold))
	}
	if l.UserEnabledEQ != nil {
		predicates = append(predicates, user.EnabledEQ(*l.UserEnabledEQ))
	}
	if l.UserEmailEQ != nil {
		predicates = append(predicates, user.EmailEQ(*l.UserEmailEQ))
	}
	if l.UserEmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*l.UserEmailNEQ))
	}
	if l.UserEmailIn != nil {
		predicates = append(predicates, user.EmailIn(l.UserEmailIn...))
	}
	if l.UserEmailNotIn != nil {
		predicates = append(predicates, user.EmailNotIn(l.UserEmailNotIn...))
	}
	if l.UserEmailContains != nil {
		predicates = append(predicates, user.EmailContains(*l.UserEmailContains))
	}
	if l.UserEmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*l.UserEmailHasPrefix))
	}
	if l.UserEmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*l.UserEmailHasSuffix))
	}
	if l.UserEmailIsNil != nil {
		if *l.UserEmailIsNil {
			predicates = append(predicates, user.EmailIsNil())
		} else {
			predicates = append(predicates, user.Not(user.EmailIsNil()))
		}
	}
	if l.UserEmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*l.UserEmailEqualFold))
	}
	if l.UserEmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*l.UserEmailContainsFold))
	}
	if l.EdgeHasPet != nil {
		if *l.EdgeHasPet {
			predicates = append(predicates, user.HasPets())
		} else {
			predicates = append(predicates, user.Not(user.HasPets()))
		}
	}
	if l.EdgePetNameEQ != nil {
		predicates = append(predicates, user.HasPetsWith(pet.NameEQ(*l.EdgePetNameEQ)))
	}
	if l.EdgePetNameNEQ != nil {
		predicates = append(predicates, user.HasPetsWith(pet.NameNEQ(*l.EdgePetNameNEQ)))
	}
	if l.EdgePetNameIn != nil {
		predicates = append(predicates, user.HasPetsWith(pet.NameIn(l.EdgePetNameIn...)))
	}
	if l.EdgePetNameNotIn != nil {
		predicates = append(predicates, user.HasPetsWith(pet.NameNotIn(l.EdgePetNameNotIn...)))
	}
	if l.EdgePetNameContains != nil {
		predicates = append(predicates, user.HasPetsWith(pet.NameContains(*l.EdgePetNameContains)))
	}
	if l.EdgePetNameHasPrefix != nil {
		predicates = append(predicates, user.HasPetsWith(pet.NameHasPrefix(*l.EdgePetNameHasPrefix)))
	}
	if l.EdgePetNameHasSuffix != nil {
		predicates = append(predicates, user.HasPetsWith(pet.NameHasSuffix(*l.EdgePetNameHasSuffix)))
	}
	if l.EdgePetNameEqualFold != nil {
		predicates = append(predicates, user.HasPetsWith(pet.NameEqualFold(*l.EdgePetNameEqualFold)))
	}
	if l.EdgePetNameContainsFold != nil {
		predicates = append(predicates, user.HasPetsWith(pet.NameContainsFold(*l.EdgePetNameContainsFold)))
	}
	if l.EdgePetNicknamesIsNil != nil {
		if *l.EdgePetNicknamesIsNil {
			predicates = append(predicates, user.HasPetsWith(pet.NicknamesIsNil()))
		} else {
			predicates = append(predicates, user.Not(user.HasPetsWith(pet.NicknamesIsNil())))
		}
	}
	if l.EdgePetAgeEQ != nil {
		predicates = append(predicates, user.HasPetsWith(pet.AgeEQ(*l.EdgePetAgeEQ)))
	}
	if l.EdgePetAgeNEQ != nil {
		predicates = append(predicates, user.HasPetsWith(pet.AgeNEQ(*l.EdgePetAgeNEQ)))
	}
	if l.EdgePetAgeIn != nil {
		predicates = append(predicates, user.HasPetsWith(pet.AgeIn(l.EdgePetAgeIn...)))
	}
	if l.EdgePetAgeNotIn != nil {
		predicates = append(predicates, user.HasPetsWith(pet.AgeNotIn(l.EdgePetAgeNotIn...)))
	}
	if l.EdgePetAgeGT != nil {
		predicates = append(predicates, user.HasPetsWith(pet.AgeGT(*l.EdgePetAgeGT)))
	}
	if l.EdgePetAgeLT != nil {
		predicates = append(predicates, user.HasPetsWith(pet.AgeLT(*l.EdgePetAgeLT)))
	}
	if l.EdgePetAgeIsNil != nil {
		if *l.EdgePetAgeIsNil {
			predicates = append(predicates, user.HasPetsWith(pet.AgeIsNil()))
		} else {
			predicates = append(predicates, user.Not(user.HasPetsWith(pet.AgeIsNil())))
		}
	}
	if l.EdgeHasFollowedPet != nil {
		if *l.EdgeHasFollowedPet {
			predicates = append(predicates, user.HasFollowedPets())
		} else {
			predicates = append(predicates, user.Not(user.HasFollowedPets()))
		}
	}
	if l.EdgeFollowedPetNameEQ != nil {
		predicates = append(predicates, user.HasFollowedPetsWith(pet.NameEQ(*l.EdgeFollowedPetNameEQ)))
	}
	if l.EdgeFollowedPetNameNEQ != nil {
		predicates = append(predicates, user.HasFollowedPetsWith(pet.NameNEQ(*l.EdgeFollowedPetNameNEQ)))
	}
	if l.EdgeFollowedPetNameIn != nil {
		predicates = append(predicates, user.HasFollowedPetsWith(pet.NameIn(l.EdgeFollowedPetNameIn...)))
	}
	if l.EdgeFollowedPetNameNotIn != nil {
		predicates = append(predicates, user.HasFollowedPetsWith(pet.NameNotIn(l.EdgeFollowedPetNameNotIn...)))
	}
	if l.EdgeFollowedPetNameContains != nil {
		predicates = append(predicates, user.HasFollowedPetsWith(pet.NameContains(*l.EdgeFollowedPetNameContains)))
	}
	if l.EdgeFollowedPetNameHasPrefix != nil {
		predicates = append(predicates, user.HasFollowedPetsWith(pet.NameHasPrefix(*l.EdgeFollowedPetNameHasPrefix)))
	}
	if l.EdgeFollowedPetNameHasSuffix != nil {
		predicates = append(predicates, user.HasFollowedPetsWith(pet.NameHasSuffix(*l.EdgeFollowedPetNameHasSuffix)))
	}
	if l.EdgeFollowedPetNameEqualFold != nil {
		predicates = append(predicates, user.HasFollowedPetsWith(pet.NameEqualFold(*l.EdgeFollowedPetNameEqualFold)))
	}
	if l.EdgeFollowedPetNameContainsFold != nil {
		predicates = append(predicates, user.HasFollowedPetsWith(pet.NameContainsFold(*l.EdgeFollowedPetNameContainsFold)))
	}
	if l.EdgeFollowedPetNicknamesIsNil != nil {
		if *l.EdgeFollowedPetNicknamesIsNil {
			predicates = append(predicates, user.HasFollowedPetsWith(pet.NicknamesIsNil()))
		} else {
			predicates = append(predicates, user.Not(user.HasFollowedPetsWith(pet.NicknamesIsNil())))
		}
	}
	if l.EdgeFollowedPetAgeEQ != nil {
		predicates = append(predicates, user.HasFollowedPetsWith(pet.AgeEQ(*l.EdgeFollowedPetAgeEQ)))
	}
	if l.EdgeFollowedPetAgeNEQ != nil {
		predicates = append(predicates, user.HasFollowedPetsWith(pet.AgeNEQ(*l.EdgeFollowedPetAgeNEQ)))
	}
	if l.EdgeFollowedPetAgeIn != nil {
		predicates = append(predicates, user.HasFollowedPetsWith(pet.AgeIn(l.EdgeFollowedPetAgeIn...)))
	}
	if l.EdgeFollowedPetAgeNotIn != nil {
		predicates = append(predicates, user.HasFollowedPetsWith(pet.AgeNotIn(l.EdgeFollowedPetAgeNotIn...)))
	}
	if l.EdgeFollowedPetAgeGT != nil {
		predicates = append(predicates, user.HasFollowedPetsWith(pet.AgeGT(*l.EdgeFollowedPetAgeGT)))
	}
	if l.EdgeFollowedPetAgeLT != nil {
		predicates = append(predicates, user.HasFollowedPetsWith(pet.AgeLT(*l.EdgeFollowedPetAgeLT)))
	}
	if l.EdgeFollowedPetAgeIsNil != nil {
		if *l.EdgeFollowedPetAgeIsNil {
			predicates = append(predicates, user.HasFollowedPetsWith(pet.AgeIsNil()))
		} else {
			predicates = append(predicates, user.Not(user.HasFollowedPetsWith(pet.AgeIsNil())))
		}
	}
	if l.EdgeHasFriend != nil {
		if *l.EdgeHasFriend {
			predicates = append(predicates, user.HasFriends())
		} else {
			predicates = append(predicates, user.Not(user.HasFriends()))
		}
	}
	if l.EdgeFriendCreatedAtGT != nil {
		predicates = append(predicates, user.HasFriendsWith(user.CreatedAtGT(*l.EdgeFriendCreatedAtGT)))
	}
	if l.EdgeFriendCreatedAtLT != nil {
		predicates = append(predicates, user.HasFriendsWith(user.CreatedAtLT(*l.EdgeFriendCreatedAtLT)))
	}
	if l.EdgeFriendUpdatedAtGT != nil {
		predicates = append(predicates, user.HasFriendsWith(user.UpdatedAtGT(*l.EdgeFriendUpdatedAtGT)))
	}
	if l.EdgeFriendUpdatedAtLT != nil {
		predicates = append(predicates, user.HasFriendsWith(user.UpdatedAtLT(*l.EdgeFriendUpdatedAtLT)))
	}
	if l.EdgeFriendNameEQ != nil {
		predicates = append(predicates, user.HasFriendsWith(user.NameEQ(*l.EdgeFriendNameEQ)))
	}
	if l.EdgeFriendNameNEQ != nil {
		predicates = append(predicates, user.HasFriendsWith(user.NameNEQ(*l.EdgeFriendNameNEQ)))
	}
	if l.EdgeFriendNameIn != nil {
		predicates = append(predicates, user.HasFriendsWith(user.NameIn(l.EdgeFriendNameIn...)))
	}
	if l.EdgeFriendNameNotIn != nil {
		predicates = append(predicates, user.HasFriendsWith(user.NameNotIn(l.EdgeFriendNameNotIn...)))
	}
	if l.EdgeFriendNameContains != nil {
		predicates = append(predicates, user.HasFriendsWith(user.NameContains(*l.EdgeFriendNameContains)))
	}
	if l.EdgeFriendNameHasPrefix != nil {
		predicates = append(predicates, user.HasFriendsWith(user.NameHasPrefix(*l.EdgeFriendNameHasPrefix)))
	}
	if l.EdgeFriendNameHasSuffix != nil {
		predicates = append(predicates, user.HasFriendsWith(user.NameHasSuffix(*l.EdgeFriendNameHasSuffix)))
	}
	if l.EdgeFriendNameEqualFold != nil {
		predicates = append(predicates, user.HasFriendsWith(user.NameEqualFold(*l.EdgeFriendNameEqualFold)))
	}
	if l.EdgeFriendNameContainsFold != nil {
		predicates = append(predicates, user.HasFriendsWith(user.NameContainsFold(*l.EdgeFriendNameContainsFold)))
	}
	if l.EdgeFriendTypeEQ != nil {
		predicates = append(predicates, user.HasFriendsWith(user.TypeEQ(*l.EdgeFriendTypeEQ)))
	}
	if l.EdgeFriendTypeNEQ != nil {
		predicates = append(predicates, user.HasFriendsWith(user.TypeNEQ(*l.EdgeFriendTypeNEQ)))
	}
	if l.EdgeFriendTypeIn != nil {
		predicates = append(predicates, user.HasFriendsWith(user.TypeIn(l.EdgeFriendTypeIn...)))
	}
	if l.EdgeFriendTypeNotIn != nil {
		predicates = append(predicates, user.HasFriendsWith(user.TypeNotIn(l.EdgeFriendTypeNotIn...)))
	}
	if l.EdgeFriendDescriptionContains != nil {
		predicates = append(predicates, user.HasFriendsWith(user.DescriptionContains(*l.EdgeFriendDescriptionContains)))
	}
	if l.EdgeFriendDescriptionIsNil != nil {
		if *l.EdgeFriendDescriptionIsNil {
			predicates = append(predicates, user.HasFriendsWith(user.DescriptionIsNil()))
		} else {
			predicates = append(predicates, user.Not(user.HasFriendsWith(user.DescriptionIsNil())))
		}
	}
	if l.EdgeFriendDescriptionContainsFold != nil {
		predicates = append(predicates, user.HasFriendsWith(user.DescriptionContainsFold(*l.EdgeFriendDescriptionContainsFold)))
	}
	if l.EdgeFriendEnabledEQ != nil {
		predicates = append(predicates, user.HasFriendsWith(user.EnabledEQ(*l.EdgeFriendEnabledEQ)))
	}
	if l.EdgeFriendEmailEQ != nil {
		predicates = append(predicates, user.HasFriendsWith(user.EmailEQ(*l.EdgeFriendEmailEQ)))
	}
	if l.EdgeFriendEmailNEQ != nil {
		predicates = append(predicates, user.HasFriendsWith(user.EmailNEQ(*l.EdgeFriendEmailNEQ)))
	}
	if l.EdgeFriendEmailIn != nil {
		predicates = append(predicates, user.HasFriendsWith(user.EmailIn(l.EdgeFriendEmailIn...)))
	}
	if l.EdgeFriendEmailNotIn != nil {
		predicates = append(predicates, user.HasFriendsWith(user.EmailNotIn(l.EdgeFriendEmailNotIn...)))
	}
	if l.EdgeFriendEmailContains != nil {
		predicates = append(predicates, user.HasFriendsWith(user.EmailContains(*l.EdgeFriendEmailContains)))
	}
	if l.EdgeFriendEmailHasPrefix != nil {
		predicates = append(predicates, user.HasFriendsWith(user.EmailHasPrefix(*l.EdgeFriendEmailHasPrefix)))
	}
	if l.EdgeFriendEmailHasSuffix != nil {
		predicates = append(predicates, user.HasFriendsWith(user.EmailHasSuffix(*l.EdgeFriendEmailHasSuffix)))
	}
	if l.EdgeFriendEmailIsNil != nil {
		if *l.EdgeFriendEmailIsNil {
			predicates = append(predicates, user.HasFriendsWith(user.EmailIsNil()))
		} else {
			predicates = append(predicates, user.Not(user.HasFriendsWith(user.EmailIsNil())))
		}
	}
	if l.EdgeFriendEmailEqualFold != nil {
		predicates = append(predicates, user.HasFriendsWith(user.EmailEqualFold(*l.EdgeFriendEmailEqualFold)))
	}
	if l.EdgeFriendEmailContainsFold != nil {
		predicates = append(predicates, user.HasFriendsWith(user.EmailContainsFold(*l.EdgeFriendEmailContainsFold)))
	}
	if l.EdgeHasFollowing != nil {
		if *l.EdgeHasFollowing {
			predicates = append(predicates, user.HasFollowing())
		} else {
			predicates = append(predicates, user.Not(user.HasFollowing()))
		}
	}
	if l.EdgeHasFriendship != nil {
		if *l.EdgeHasFriendship {
			predicates = append(predicates, user.HasFriendships())
		} else {
			predicates = append(predicates, user.Not(user.HasFriendships()))
		}
	}
	return l.ApplyFilterOperation(predicates...)
}

// ApplySorting applies sorting to the query based on the provided sort and order fields.
func (l *ListUserParams) ApplySorting(query *ent.UserQuery) (*ent.UserQuery, error) {
	if l.Sort == nil {
		return query, nil
	}
	if err := l.Sorted.Validate(UserSortFields); err != nil {
		return nil, err
	}
	if parts := strings.Split(*l.Sort, "."); len(parts) > 1 {
		dir := l.Sorted.SortOrderTerm()

		var isCount, isSum bool
		if len(parts) > 2 {
			switch parts[2] {
			case "count":
				isCount = true
			case "sum":
				isSum = true
			}
		}

		switch parts[0] {
		case user.EdgePets:
			switch {
			case isCount:
				return query.Order(user.ByPetsCount(dir)), nil
			case isSum:
				return query.Order(user.ByPets(sql.OrderBySum(parts[1], dir))), nil
			default:
				return query.Order(user.ByPets(sql.OrderByField(parts[1], dir))), nil
			}
		case user.EdgeFollowedPets:
			switch {
			case isCount:
				return query.Order(user.ByFollowedPetsCount(dir)), nil
			case isSum:
				return query.Order(user.ByFollowedPets(sql.OrderBySum(parts[1], dir))), nil
			default:
				return query.Order(user.ByFollowedPets(sql.OrderByField(parts[1], dir))), nil
			}
		case user.EdgeFriends:
			switch {
			case isCount:
				return query.Order(user.ByFriendsCount(dir)), nil
			case isSum:
				return query.Order(user.ByFriends(sql.OrderBySum(parts[1], dir))), nil
			default:
				return query.Order(user.ByFriends(sql.OrderByField(parts[1], dir))), nil
			}
		case user.EdgeFollowing:
			switch {
			case isCount:
				return query.Order(user.ByFollowingCount(dir)), nil
			case isSum:
				return query.Order(user.ByFollowing(sql.OrderBySum(parts[1], dir))), nil
			default:
				return query.Order(user.ByFollowing(sql.OrderByField(parts[1], dir))), nil
			}
		case user.EdgeFriendships:
			switch {
			case isCount:
				return query.Order(user.ByFriendshipsCount(dir)), nil
			case isSum:
				return query.Order(user.ByFriendships(sql.OrderBySum(parts[1], dir))), nil
			default:
				return query.Order(user.ByFriendships(sql.OrderByField(parts[1], dir))), nil
			}
		}
	}
	if *l.Sort == "random" {
		return query.Order(sql.OrderByRand()), nil
	}
	return query.Order(l.Sorted.SortFieldSelector()), nil
}

// Exec wraps all logic (filtering, sorting, pagination, eager loading) and
// executes all necessary queries, returning the results.
func (l *ListUserParams) Exec(ctx context.Context, query *ent.UserQuery) (results *PagedResponse[ent.User], err error) {
	predicates, err := l.FilterPredicates()
	if err != nil {
		return nil, err
	}
	query = query.Where(predicates)
	query, err = l.ApplySorting(EagerLoadUser(query))
	if err != nil {
		return nil, err
	}
	return l.ExecutePaginated(ctx, query, UserPageConfig)
}
