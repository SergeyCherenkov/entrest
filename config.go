// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.

package entrest

import (
	"encoding/json"
	"fmt"
	"net/http"
	"slices"

	"entgo.io/ent/entc"
	"entgo.io/ent/entc/gen"
	"github.com/ogen-go/ogen"
)

var _ entc.Annotation = (*Config)(nil)

// Config holds the main configuration for this extension.
type Config struct {
	isValidated bool

	// Spec is an optional default spec to merge all generated endpoints/schemas/etc
	// into, which will allow you to specify API info, servers, security schemes, etc.
	Spec *ogen.Spec

	// DisablePagination disables pagination support for all schemas by default.
	// It scan still be enabled on a per-schema basis with annotations.
	DisablePagination bool

	// MinItemsPerPage controls the default minimum number of items per page, for
	// paginated calls. This can be overridden on a per-schema basis with annotations.
	MinItemsPerPage int

	// MaxItemsPerPage controls the default maximum number of items per page, for
	// paginated calls. This can be overridden on a per-schema basis with annotations.
	MaxItemsPerPage int

	// ItemsPerPage controls the default number of items per page, for paginated calls.
	// This can be overridden on a per-schema basis with annotations.
	ItemsPerPage int

	// DisableTotalCount disables the inclusion of a "total_count" field in the response
	// for paginated calls, which can be useful for clients which don't need to know the
	// total number of items in the collection, and requires additional database calls.
	DisableTotalCount bool

	// DefaultEagerLoad enables eager loading of all edges by default. This can be
	// overridden on a per-edge basis with annotations. If edges load a lot of data
	// or are expensive, this can be a performance hit and isn't recommended.
	DefaultEagerLoad bool

	// DisableEagerLoadNonPagedOpt disables the optimization which automatically disables
	// the pagination for edge endpoints where the edge was also eager-loaded. The idea for
	// the optimization is that if the edge is also eager-loaded, then the amount of data
	// isn't large enough to justify the additional overhead of pagination, so we can
	// disable it.
	DisableEagerLoadNonPagedOpt bool

	// DisableEagerLoadedEndpoints disables the generation of dedicated endpoints for
	// edges which are also eager-loaded. This can be useful to reduce the number of
	// endpoints generated, but does mean that callers would have to always call the
	// entity which eager loads the edge, rather than only fetching the edge itself.
	// This can be overridden on a per-edge basis with annotations.
	//
	// Example: Given a schema with users and pets, and an edge on pets called "owner",
	// pointing to user, if you configure owner to be eager-loaded (so any time you query
	// a pet, you also get the owner), setting this to true will then disable the
	// /pets/{id}/owner endpoint (idea being that you could just call /pets/{id} and
	// get the owner from that response).
	DisableEagerLoadedEndpoints bool

	// AddEdgesToTags enables the addition of edge fields to the "tags" field in the
	// OpenAPI spec. This is helpful to see if querying a specific entity also returns
	// the thing you're looking for, though can be very noisy for large schemas. Note
	// that edge endpoints (e.g. /users/{id}/pets) will still have both "User" and "Pet"
	// in the tags, this only affects eager-loaded edges.
	AddEdgesToTags bool

	// DefaultOperations is a list of operations to generate by default. If nil,
	// all operations will be generated by default (unless excluded with annotations).
	DefaultOperations []Operation

	// GlobalRequestHeaders are headers to add to every request, which can be optional
	// (e.g. X-Request-Id or X-Correlation-ID), or required (e.g. API version). Note
	// that these should not include anything related to authentication -- use the
	// security schemes instead via [Config.Spec].
	GlobalRequestHeaders map[string]*ogen.Parameter

	// GlobalResponseHeaders are headers to add to every response, recommended for headers
	// like X-Ratelimit-Limit, X-Ratelimit-Remaining, X-Ratelimit-Reset, etc.
	GlobalResponseHeaders map[string]*ogen.Header

	// GlobalErrorResponses are status code -> response mappings for errors, which are
	// added to all path operations. Note that some status codes are excluded on specific
	// operations (e.g. 404 on list, 409 on non-create/update, etc). If not specified,
	// a default set of responses will be generated which can be used with entrest's
	// built-in auto-generated HTTP handlers.
	GlobalErrorResponses map[int]*ogen.Schema

	// Handler enables the generation of HTTP handlers for the specified server/routing
	// library. Use HandlerGeneric if yours isn't supported, which should allow you to
	// wire up the handlers yourself.
	Handler SupportedHTTPHandler

	// EnableDocsHandler enables the generation of an OpenAPI UI documentation handler.
	// TODO: make this more configurable?
	EnableDocsHandler bool
	DocsHandlerConfig map[string]string

	// EnableSpecHandler enables the generation of an OpenAPI spec handler (e.g.
	// /openapi.json). Disabling this will also disable embedding the spec into the
	// binary/rest generated library.
	EnableSpecHandler bool

	// AllowClientIDs, when enabled, allows the built-in "id" field as part of a "Create"
	// payload for entity creation, allowing the client to supply UUIDs as primary keys
	// and for idempotency.
	AllowClientUUIDs bool

	// PatchJSONTag enables a ent generation hook that patches the JSON tag of all fields
	// in the schema, removing the usage of omitempty. This helps ensure that fields that
	// have default values and/or aren't required, still get returned in JSON response
	// bodies. Skips over fields which are json-excluded (e.g. sensitive data).
	PatchJSONTag bool
}

func (c *Config) Validate() error {
	if c.isValidated {
		return nil
	}

	if c.MinItemsPerPage < 1 {
		c.MinItemsPerPage = defaultMinItemsPerPage
	}

	if c.MaxItemsPerPage < 1 {
		c.MaxItemsPerPage = defaultMaxItemsPerPage
	}

	if c.MaxItemsPerPage < c.MinItemsPerPage {
		c.MaxItemsPerPage = c.MinItemsPerPage
	}

	if c.ItemsPerPage < 1 {
		c.ItemsPerPage = defaultItemsPerPage
	}

	if c.ItemsPerPage < c.MinItemsPerPage {
		c.ItemsPerPage = c.MinItemsPerPage
	}

	if c.ItemsPerPage > c.MaxItemsPerPage {
		c.ItemsPerPage = c.MaxItemsPerPage
	}

	if c.DefaultOperations == nil {
		c.DefaultOperations = AllOperations
	}

	if len(c.GlobalErrorResponses) == 0 {
		c.GlobalErrorResponses = map[int]*ogen.Schema{
			http.StatusBadRequest:          defaultErrorResponse(http.StatusBadRequest),
			http.StatusUnauthorized:        defaultErrorResponse(http.StatusUnauthorized),
			http.StatusForbidden:           defaultErrorResponse(http.StatusForbidden),
			http.StatusNotFound:            defaultErrorResponse(http.StatusNotFound),
			http.StatusConflict:            defaultErrorResponse(http.StatusConflict),
			http.StatusTooManyRequests:     defaultErrorResponse(http.StatusTooManyRequests),
			http.StatusInternalServerError: defaultErrorResponse(http.StatusInternalServerError),
		}
	}

	for k := range c.GlobalErrorResponses {
		if k < 400 {
			return fmt.Errorf("error response defined with status code %d, which is not an HTTP error code", k)
		}
	}

	if c.Handler != "" && !slices.Contains(AllSupportedHTTPHandlers, c.Handler) {
		return fmt.Errorf("unsupported handler provided: %s", c.Handler)
	}

	c.isValidated = true
	return nil
}

func (c Config) Name() string {
	return "EntRestConfig"
}

func (c *Config) Decode(o any) error {
	buf, err := json.Marshal(o)
	if err != nil {
		return err
	}
	return json.Unmarshal(buf, c) //nolint:musttag
}

func GetConfig(gc *gen.Config) *Config {
	c := &Config{}
	if gc != nil && gc.Annotations != nil && gc.Annotations[c.Name()] != nil {
		if err := c.Decode(gc.Annotations[c.Name()]); err != nil {
			panic(fmt.Sprintf("failed to decode config: %v", err))
		}
	}
	err := c.Validate()
	if err != nil {
		panic(fmt.Sprintf("failed to validate config: %v", err))
	}
	return c
}
