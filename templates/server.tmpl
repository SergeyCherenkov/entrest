{{- /*
  Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
  this source code is governed by the MIT license that can be found in
  the LICENSE file.
*/ -}}
{{- define "rest/server" }}
{{- with extend $ "Package" "rest" }}{{ template "header" . }}{{ end }}

import (
    "{{ $.Config.Package }}"
    {{- with $.Config.FeatureEnabled "privacy" }}
        "{{ $.Config.Package }}/privacy"
    {{- end }}
    {{- range $t := $.Nodes }}
        "{{ $.Config.Package }}/{{ $t.Package }}"
    {{- end }}
    {{- if not $.Annotations.RestConfig.DisableSpecHandler }}
        _ "embed"
    {{- end }}
    {{- if eq $.Annotations.RestConfig.Handler "chi" }}
        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
    {{- end }}
    "github.com/go-playground/form/v4"
)

{{ template "helper/rest/server/constants" . }}
{{ template "helper/rest/server/errors" . }}
{{ template "helper/rest/server/json" . }}
{{ template "helper/rest/server/bind" . }}
{{ template "helper/rest/server/req" . }}
{{ template "helper/rest/server/links" . }}

type ServerConfig struct {
    {{- if not $.Annotations.RestConfig.DisableSpecHandler }}
        // BaseURL is similar to [ServerConfig.BasePath], however, only the path of the URL is used
        // to prefill BasePath. This is not required if BasePath is provided.
        BaseURL string

        // BasePath if provided, and the /openapi.json endpoint is enabled, will allow annotating
        // API responses with "Link" headers. See [ServerConfig.EnableLinks] for more information.
        BasePath string

        // DisableSpecHandler if set to true, will disable the /openapi.json endpoint.
        DisableSpecHandler bool
    {{- end }}

    // EnableLinks if set to true, will enable the "Link" response header, which can be used to hint
    // to clients about the location of the OpenAPI spec, API documentation, how to auto-paginate
    // through results, and more.
    EnableLinks bool

    // MaskErrors if set to true, will mask the error message returned to the client,
    // returning a generic error message based on the HTTP status code.
    MaskErrors bool

    // ErrorHandler is invoked when an error occurs. If not provided, the default
    // error handling logic will be used. If you want to run logic on errors, but
    // not actually handle the error yourself, you can still call [Server.DefaultErrorHandler]
    // after your logic.
    ErrorHandler func(w http.ResponseWriter, r *http.Request, op Operation, err error)

    // GetReqID returns the request ID for the given request. If not provided, the
    // default implementation will use the X-Request-Id header, otherwise an empty
    // string will be returned. If using go-chi, middleware.GetReqID will be used.
    GetReqID func(r *http.Request) string
}

type Server struct {
    db     *ent.Client
    config *ServerConfig
}

// NewServer returns a new auto-generated server implementation for your ent schema.
// [Server.Handler] returns a ready-to-use http.Handler that mounts all of the
// necessary endpoints.
func NewServer(db *ent.Client, config *ServerConfig) (*Server, error) {
    if config == nil {
        config = &ServerConfig{}
    }

    {{- if not $.Annotations.RestConfig.DisableSpecHandler }}
        if config.BaseURL != "" && config.BasePath == "" {
            uri, err := url.Parse(config.BaseURL)
            if err != nil {
                return nil, fmt.Errorf("failed to parse BaseURL: %w", err)
            }
            config.BasePath = uri.Path
        }

        if config.BasePath != "" {
            if !strings.HasPrefix(config.BasePath, "/") {
                config.BasePath = "/" + config.BasePath
            }
            config.BasePath = strings.TrimRight(config.BasePath, "/")
        }
    {{- end }}

    return &Server{db: db, config: config}, nil
}

// DefaultErrorHandler is the default error handler for the Server.
func (s *Server) DefaultErrorHandler(w http.ResponseWriter, r *http.Request, op Operation, err error) {
    ts := time.Now().UTC().Format(time.RFC3339)

    resp := ErrorResponse{
        Error:     err.Error(),
        Timestamp: ts,
    }

    var numErr *strconv.NumError

    switch {
    case IsEndpointNotFound(err):
        resp.Code = http.StatusNotFound
    case IsMethodNotAllowed(err):
        resp.Code = http.StatusMethodNotAllowed
    case IsBadRequest(err):
        resp.Code = http.StatusBadRequest
    {{- with $.Config.FeatureEnabled "privacy" }}
        case errors.Is(err, privacy.Deny):
            resp.Code = http.StatusForbidden
    {{- end }}
    case ent.IsNotFound(err):
        if op == OperationList {
            resp.Type = "No results found matching the given query"
        }
        resp.Code = http.StatusNotFound
    case ent.IsConstraintError(err), ent.IsNotSingular(err):
        resp.Code = http.StatusConflict
    case ent.IsValidationError(err):
        resp.Code = http.StatusBadRequest
    case errors.As(err, &numErr):
        resp.Code = http.StatusBadRequest
        resp.Error = fmt.Sprintf("invalid ID provided: %v", err)
    default:
        resp.Code = http.StatusInternalServerError
    }

    if resp.Type == "" {
        resp.Type = http.StatusText(resp.Code)
    }
    if s.config.MaskErrors {
        resp.Error = http.StatusText(resp.Code)
    }
    if s.config.GetReqID != nil {
        resp.RequestID = s.config.GetReqID(r)
    } else {
        {{- if eq $.Annotations.RestConfig.Handler "chi" }}
            resp.RequestID = middleware.GetReqID(r.Context())
        {{- else }}
            resp.RequestID = r.Header.Get("X-Request-Id")
        {{- end }}
    }
    JSON(w, r, resp.Code, resp)
}

func handleResponse[Resp any](s *Server, w http.ResponseWriter, r *http.Request, op Operation, resp *Resp, err error) {
    if s.config.EnableLinks {
        links := Links{}

        {{- if not $.Annotations.RestConfig.DisableSpecHandler }}
            if !s.config.DisableSpecHandler {
                links["service-desc"] = s.config.BasePath + "/openapi.json"
                links["describedby"] = s.config.BasePath + "/openapi.json"
            }
        {{- end }}

        if err == nil && resp != nil && op == OperationList {
            if lr, ok := any(resp).(linkablePagedResource); ok {
                query := r.URL.Query()
                if page := lr.GetPage(); page > 1 {
                    query.Set("page", strconv.Itoa(page-1))
                    r.URL.RawQuery = query.Encode()
                    links["prev"] = r.URL.String()
                    if !strings.HasPrefix(links["prev"], s.config.BasePath) {
                        links["prev"] = s.config.BasePath + links["prev"]
                    }
                }
                if !lr.GetIsLastPage() {
                    query.Set("page", strconv.Itoa(lr.GetPage()+1))
                    r.URL.RawQuery = query.Encode()
                    links["next"] = r.URL.String()
                    if !strings.HasPrefix(links["next"], s.config.BasePath) {
                        links["next"] = s.config.BasePath + links["next"]
                    }
                }
            }
        }

        if v := links.String(); v != "" {
            w.Header().Set("Link", v)
        }
    }

    if err != nil {
        if s.config.ErrorHandler != nil {
            s.config.ErrorHandler(w, r, op, err)
            return
        }
        s.DefaultErrorHandler(w, r, op, err)
        return
    }
    if resp != nil {
        if r.Method == http.MethodPost {
            JSON(w, r, http.StatusCreated, resp)
            return
        }
        JSON(w, r, http.StatusOK, resp)
        return
    }
    w.WriteHeader(http.StatusNoContent)
}

{{- if eq $.Annotations.RestConfig.Handler "chi" }}
    // Handler mounts all of the necessary endpoints onto the provided chi.Router.
    func (s *Server) Handler(r chi.Router) {
{{- else }}
    // Handler returns a ready-to-use http.Handler that mounts all of the necessary endpoints.
    func (s *Server) Handler() http.Handler {
{{- end }}
    {{- if eq $.Annotations.RestConfig.Handler "stdlib" }}
        mux := http.NewServeMux()
    {{ end }}

    {{- range $t := $.Nodes }}
        {{- if (($t|getAnnotation).GetSkip $t.Config.Annotations.RestConfig) }}{{ continue }}{{ end }}

        {{- /* list nodes */}}
        {{- if ($t|getAnnotation).HasOperation $t.Config.Annotations.RestConfig "list" }}
            {{- template "helper/rest/server/endpoint" (dict
                "Handler" $.Annotations.RestConfig.Handler
                "Method" "GET"
                "Path" (printf "/%s" ($t.Name|zkebab|zplural))
                "Func" (printf "ReqParam(s, OperationList, s.List%s)" ($t.Name|zsingular))
            ) }}
        {{- end }}

        {{- /* get single node */}}
        {{- if and $t.ID (($t|getAnnotation).HasOperation $t.Config.Annotations.RestConfig "read") }}
            {{- template "helper/rest/server/endpoint" (dict
                "Handler" $.Annotations.RestConfig.Handler
                "Method" "GET"
                "Path" (printf "/%s/{id}" ($t.Name|zkebab|zplural))
                "Func" (printf "ReqID(s, OperationRead, s.Read%sByID)" ($t.Name|zsingular))
            ) }}
        {{- end }}

        {{- range $e := $t.Edges }}
            {{- if or $e.Annotations.Rest.ReadOnly (not $e.Type.ID) (not $t.ID) }}{{ continue }}{{ end }}

            {{- /* get nodes edge (unique) */}}
            {{- if and $e.Unique (($t|getAnnotation).HasOperation $t.Config.Annotations.RestConfig "read") }}
                {{- template "helper/rest/server/endpoint" (dict
                    "Handler" $.Annotations.RestConfig.Handler
                    "Method" "GET"
                    "Path" (printf "/%s/{id}/%s" ($t.Name|zkebab|zplural) ($e.StructField|zkebab))
                    "Func" (printf "ReqID(s, OperationRead, s.EdgeRead%s%sByID)" ($t.Name|zsingular) ($e.StructField))
                ) }}
            {{- end }}

            {{- /* list nodes edge (non-unique) */}}
            {{- if and (not $e.Unique) (($t|getAnnotation).HasOperation $t.Config.Annotations.RestConfig "list") }}
                {{- template "helper/rest/server/endpoint" (dict
                    "Handler" $.Annotations.RestConfig.Handler
                    "Method" "GET"
                    "Path" (printf "/%s/{id}/%s" ($t.Name|zkebab|zplural) ($e.StructField|zkebab))
                    "Func" (printf "ReqIDParam(s, OperationList, s.EdgeList%s%sByID)" ($t.Name|zsingular) ($e.StructField))
                ) }}
            {{- end }}
        {{- end }}

        {{- /* create nodes */}}
        {{- if ($t|getAnnotation).HasOperation $t.Config.Annotations.RestConfig "create" }}
            {{- template "helper/rest/server/endpoint" (dict
                "Handler" $.Annotations.RestConfig.Handler
                "Method" "POST"
                "Path" (printf "/%s" ($t.Name|zkebab|zplural))
                "Func" (printf "ReqParam(s, OperationCreate, s.Create%s)" ($t.Name|zsingular))
            ) }}
        {{- end }}

        {{- /* update nodes */}}
        {{- if and $t.ID (($t|getAnnotation).HasOperation $t.Config.Annotations.RestConfig "update") }}
            {{- template "helper/rest/server/endpoint" (dict
                "Handler" $.Annotations.RestConfig.Handler
                "Method" "PATCH"
                "Path" (printf "/%s/{id}" ($t.Name|zkebab|zplural))
                "Func" (printf "ReqIDParam(s, OperationUpdate, s.Update%sByID)" ($t.Name|zsingular))
            ) }}
        {{- end }}

        {{- /* delete nodes */}}
        {{- if and $t.ID (($t|getAnnotation).HasOperation $t.Config.Annotations.RestConfig "delete") }}
            {{- template "helper/rest/server/endpoint" (dict
                "Handler" $.Annotations.RestConfig.Handler
                "Method" "DELETE"
                "Path" (printf "/%s/{id}" ($t.Name|zkebab|zplural))
                "Func" (printf "ReqID(s, OperationDelete, s.Delete%sByID)" ($t.Name|zsingular))
            ) }}
        {{- end }}
    {{- end }}

    {{ if not $.Annotations.RestConfig.DisableSpecHandler }}
        if !s.config.DisableSpecHandler {
            {{- template "helper/rest/server/endpoint" (dict
                "Handler" $.Annotations.RestConfig.Handler
                "Method" "GET"
                "Path" "/openapi.json"
                "Func" "s.Spec"
            ) }}
        }
    {{- end }}

    {{ template "helper/rest/server/not-found" . }}

    {{- if eq $.Annotations.RestConfig.Handler "stdlib" }}
        return mux
    {{- end }}
}

{{ if not $.Annotations.RestConfig.DisableSpecHandler }}
    // Spec returns the OpenAPI spec for the server implementation.
    func (s *Server) Spec(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write(OpenAPI)
    }
{{- end }}

{{- range $t := $.Nodes }}
    {{- if (($t|getAnnotation).GetSkip $t.Config.Annotations.RestConfig) }}{{ continue }}{{ end }}

    {{- /* list nodes */}}
    {{- if ($t|getAnnotation).HasOperation $t.Config.Annotations.RestConfig "list" }}
        // List{{ $t.Name|zsingular }} maps to "GET /{{ $t.Name|zkebab|zplural }}".
        func (s *Server) List{{ $t.Name|zsingular }}(r *http.Request, p *List{{ $t.Name|zsingular }}Params) (*PagedResponse[ent.{{ $t.Name }}], error) {
            return p.Exec(r.Context(), s.db.{{ $t.Name }}.Query())
        }
    {{- end }}

    {{- /* get single node */}}
    {{- if and $t.ID (($t|getAnnotation).HasOperation $t.Config.Annotations.RestConfig "read") }}
        // Read{{ $t.Name|zsingular }}ByID maps to "GET /{{ $t.Name|zkebab|zplural }}/{id}".
        func (s *Server) Read{{ $t.Name|zsingular }}ByID(r *http.Request, id int) (*ent.{{ $t.Name }}, error) {
            return EagerLoad{{ $t.Name|zsingular }}(s.db.{{ $t.Name }}.Query().Where({{ $t.Package }}.ID(id))).Only(r.Context())
        }
    {{- end }}

    {{- range $e := $t.Edges }}
        {{- if or $e.Annotations.Rest.ReadOnly (not $e.Type.ID) (not $t.ID) }}{{ continue }}{{ end }}

        {{- /* get nodes edge (unique) */}}
        {{- if and $e.Unique (($t|getAnnotation).HasOperation $t.Config.Annotations.RestConfig "read") }}
            // EdgeRead{{ $t.Name|zsingular }}{{ $e.StructField }}ByID maps to "GET /{{ $t.Name|zkebab|zplural }}/{id}/{{ $e.StructField|zkebab }}".
            func (s *Server) EdgeRead{{ $t.Name|zsingular }}{{ $e.StructField }}ByID(r *http.Request, id int) (*ent.{{ $e.Type.Name }}, error) {
                return EagerLoad{{ $e.Type.Name|zsingular }}(s.db.{{ $t.Name }}.Query().Where({{ $t.Package }}.ID(id)).Query{{ $e.StructField }}()).Only(r.Context())
            }
        {{- end }}

        {{- /* list nodes edge (non-unique) */}}
        {{- if and (not $e.Unique) (($t|getAnnotation).HasOperation $t.Config.Annotations.RestConfig "list") }}
            // EdgeList{{ $t.Name|zsingular }}{{ $e.StructField }}ByID maps to "GET /{{ $t.Name|zkebab|zplural }}/{id}/{{ $e.StructField|zkebab }}".
            func (s *Server) EdgeList{{ $t.Name|zsingular }}{{ $e.StructField }}ByID(r *http.Request, id int, p *List{{ $e.Type.Name|zsingular }}Params) (*PagedResponse[ent.{{ $e.Type.Name }}], error) {
                return p.Exec(r.Context(), s.db.{{ $t.Name }}.Query().Where({{ $t.Package }}.ID(id)).Query{{ $e.StructField }}())
            }
        {{- end }}
    {{- end }}

    {{- /* create nodes */}}
    {{- if ($t|getAnnotation).HasOperation $t.Config.Annotations.RestConfig "create" }}
        // Create{{ $t.Name|zsingular }} maps to "POST /{{ $t.Name|zkebab|zplural }}".
        func (s *Server) Create{{ $t.Name|zsingular }}(r *http.Request, p *Create{{ $t.Name|zsingular }}Params) (*ent.{{ $t.Name }}, error) {
            return p.Exec(r.Context(), s.db.{{ $t.Name }}.Create(), s.db.{{ $t.Name }}.Query())
        }
    {{- end }}

    {{- /* update nodes */}}
    {{- if and $t.ID (($t|getAnnotation).HasOperation $t.Config.Annotations.RestConfig "update") }}
        // Update{{ $t.Name|zsingular }}ByID maps to "PATCH /{{ $t.Name|zkebab|zplural }}/{id}".
        func (s *Server) Update{{ $t.Name|zsingular }}ByID(r *http.Request, id int, p *Update{{ $t.Name|zsingular }}Params) (*ent.{{ $t.Name }}, error) {
            return p.Exec(r.Context(), s.db.{{ $t.Name }}.UpdateOneID(id), s.db.{{ $t.Name }}.Query())
        }
    {{- end }}

    {{- /* delete nodes */}}
    {{- if and $t.ID (($t|getAnnotation).HasOperation $t.Config.Annotations.RestConfig "delete") }}
        // Delete{{ $t.Name|zsingular }}ByID maps to "DELETE /{{ $t.Name|zkebab|zplural }}/{id}".
        func (s *Server) Delete{{ $t.Name|zsingular }}ByID(r *http.Request, id int) (*struct{}, error) {
            return nil, s.db.{{ $t.Name }}.DeleteOneID(id).Exec(r.Context())
        }
    {{- end }}
{{ end }}
{{- end }}{{/* end template */}}
