{{- /*
  Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
  this source code is governed by the MIT license that can be found in
  the LICENSE file.
*/ -}}
{{- define "rest/server" }}
{{- with extend $ "Package" "rest" }}{{ template "header" . }}{{ end }}

import (
    "{{ $.Config.Package }}"
    {{- with $.Config.FeatureEnabled "privacy" }}
        "{{ $.Config.Package }}/privacy"
    {{- end }}
    {{- if $.Annotations.RestConfig.EnableSpecHandler }}
        _ "embed"
    {{- end }}
    "github.com/go-playground/form/v4"
)

{{- if $.Annotations.RestConfig.EnableSpecHandler }}
//go:embed openapi.json
var OpenAPI []byte // OpenAPI contains the JSON schema of the API.
{{- end }}

{{ template "helper/rest/server/errors" . }}
{{ template "helper/rest/server/helpers" . }}

type ServerConfig struct {
    // MaskErrors if set to true, will mask the error message returned to the client,
    // returning a generic error message based on the HTTP status code.
    MaskErrors bool

    // ErrorHandler is invoked when an error occurs. If not provided, the default
    // error handling logic will be used. If you want to run logic on errors, but
    // not actually handle the error yourself, you can still call [Server.DefaultErrorHandler]
    // after your logic.
    ErrorHandler func(w http.ResponseWriter, r *http.Request, err error)
}

type Server struct {
    db     *ent.Client
    config *ServerConfig
}

func NewServer(db *ent.Client, config *ServerConfig) *Server {
    if config == nil {
        config = &ServerConfig{}
    }
    return &Server{
        db:     db,
        config: config,
    }
}

// DefaultErrorHandler is the default error handler for the Server.
func (s *Server) DefaultErrorHandler(w http.ResponseWriter, r *http.Request, err error) {
    ts := time.Now().UTC().Format(time.RFC3339)

    resp := ErrorResponse{
        Error:     err.Error(),
        Timestamp: ts,
    }

    var numErr *strconv.NumError

    switch {
    case IsNotFound(err):
        resp.Code = http.StatusNotFound
    case IsBadRequest(err):
        resp.Code = http.StatusBadRequest
    {{- with $.Config.FeatureEnabled "privacy" }}
        case errors.Is(err, privacy.Deny):
            resp.Code = http.StatusForbidden
    {{- end }}
    case ent.IsNotFound(err):
        // TODO: if LIST operation, give a different type. otherwise, make the error more pretty?
        resp.Code = http.StatusNotFound
    case ent.IsConstraintError(err), ent.IsNotSingular(err):
        resp.Code = http.StatusConflict
    case ent.IsValidationError(err):
        resp.Code = http.StatusBadRequest
    // Check if strconv.Atoi's NumError.
    case errors.As(err, &numErr):
        resp.Code = http.StatusBadRequest
        resp.Error = fmt.Sprintf("invalid ID provided: %v", err)
    default:
        resp.Code = http.StatusInternalServerError
    }

    if resp.Type == "" {
        resp.Type = http.StatusText(resp.Code)
    }

    if s.config.MaskErrors {
        resp.Error = http.StatusText(resp.Code)
    }

    JSON(w, r, resp.Code, resp)
}

func (s *Server) error(w http.ResponseWriter, r *http.Request, err error) bool {
    if err == nil {
        return false
    }
    if s.config.ErrorHandler != nil {
        s.config.ErrorHandler(w, r, err)
        return true
    }
    s.DefaultErrorHandler(w, r, err)
    return true
}

{{/* TODO: we do an ID matcher like this so we don't have to explicitly validate the ID in each child handler */}}
{{- $id := "" }}
{{- if eq $.Annotations.RestConfig.Handler "chi" }}
    {{- $id = "{id:^[0-9]{1,50}$}" }}
{{- else }}
    {{- $id = "{id}" }}
{{- end }}

func (s *Server) Handler() http.Handler {
    mux := http.NewServeMux()

    {{- range $t := $.Nodes }}
        {{- if (($t|getAnnotation).GetSkip $.Annotations.RestConfig) }}{{ continue }}{{ end }}

        {{- /* list nodes */}}
        {{- if ($t|getAnnotation).HasOperation $.Annotations.RestConfig "list" }}
            mux.HandleFunc("GET /{{ $t.Name|zkebab|zplural }}", s.List{{ $t.Name|zsingular }})
        {{- end }}

        {{- /* get single node */}}
        {{- if and $t.ID (($t|getAnnotation).HasOperation $.Annotations.RestConfig "read") }}
            mux.HandleFunc("GET /{{ $t.Name|zkebab|zplural }}/{{ $id }}", s.Read{{ $t.Name|zsingular }}ByID)
        {{- end }}

        {{- range $e := $t.Edges }}
            {{- if or $e.Annotations.Rest.ReadOnly (not $e.Type.ID) (not $t.ID) }}{{ continue }}{{ end }}

            {{- /* get nodes edge (unique) */}}
            {{- if and $e.Unique (($t|getAnnotation).HasOperation $.Annotations.RestConfig "read") }}
                mux.HandleFunc("GET /{{ $t.Name|zkebab|zplural }}/{{ $id }}/{{ $e.StructField|zkebab }}", s.EdgeRead{{ $t.Name|zsingular }}{{ $e.StructField }}ByID)
            {{- end }}

            {{- /* list nodes edge (non-unique) */}}
            {{- if and (not $e.Unique) (($t|getAnnotation).HasOperation $.Annotations.RestConfig "list") }}
                mux.HandleFunc("GET /{{ $t.Name|zkebab|zplural }}/{{ $id }}/{{ $e.StructField|zkebab }}", s.EdgeList{{ $t.Name|zsingular }}{{ $e.StructField }}ByID)
            {{- end }}
        {{- end }}

        {{- /* create nodes */}}
        {{- if ($t|getAnnotation).HasOperation $.Annotations.RestConfig "create" }}
            mux.HandleFunc("POST /{{ $t.Name|zkebab|zplural }}", s.Create{{ $t.Name|zsingular }})
        {{- end }}

        {{- /* update nodes */}}
        {{- if and $t.ID (($t|getAnnotation).HasOperation $.Annotations.RestConfig "update") }}
            mux.HandleFunc("PATCH /{{ $t.Name|zkebab|zplural }}/{{ $id }}", s.Update{{ $t.Name|zsingular }}ByID)
        {{- end }}

        {{- /* delete nodes */}}
        {{- if and $t.ID (($t|getAnnotation).HasOperation $.Annotations.RestConfig "delete") }}
            mux.HandleFunc("DELETE /{{ $t.Name|zkebab|zplural }}/{{ $id }}", s.Delete{{ $t.Name|zsingular }}ByID)
        {{- end }}
    {{- end }}

    {{- if $.Annotations.RestConfig.EnableSpecHandler }}
        mux.HandleFunc("GET /openapi.json", s.Spec)
    {{- end }}

    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        _ = s.error(w, r, ErrNotFound)
    })
    return mux
}

{{- if $.Annotations.RestConfig.EnableSpecHandler }}
    func (s *Server) Spec(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write(OpenAPI)
    }
{{- end }}

{{- range $t := $.Nodes }}
    {{- if (($t|getAnnotation).GetSkip $.Annotations.RestConfig) }}{{ continue }}{{ end }}

    {{- /* list nodes */}}
    {{- if ($t|getAnnotation).HasOperation $.Annotations.RestConfig "list" }}
        // List{{ $t.Name|zsingular }} maps to "GET /{{ $t.Name|zkebab|zplural }}".
        func (s *Server) List{{ $t.Name|zsingular }}(w http.ResponseWriter, r *http.Request) {
            data := &List{{ $t.Name|zsingular }}Params{}
            if s.error(w, r, Bind(r, data)) {
                return
            }
            results, err := data.Exec(r.Context(), s.db.{{ $t.Name }}.Query())
            if s.error(w, r, err) {
                return
            }
            JSON(w, r, http.StatusOK, results)
        }
    {{- end }}

    {{- /* get single node */}}
    {{- if and $t.ID (($t|getAnnotation).HasOperation $.Annotations.RestConfig "read") }}
        // Read{{ $t.Name|zsingular }}ByID maps to "GET /{{ $t.Name|zkebab|zplural }}/{{ $id }}".
        func (s *Server) Read{{ $t.Name|zsingular }}ByID(w http.ResponseWriter, r *http.Request) {
            id, err := strconv.Atoi(r.PathValue("id"))
            if s.error(w, r, err) {
                return
            }
            results, err := EagerLoad{{ $t.Name|zsingular }}(s.db.{{ $t.Name }}.Query().Where({{ $t.Package }}.ID(id))).Only(r.Context())
            if s.error(w, r, err) {
                return
            }
            JSON(w, r, http.StatusOK, results)
        }
    {{- end }}

    {{- range $e := $t.Edges }}
        {{- if or $e.Annotations.Rest.ReadOnly (not $e.Type.ID) (not $t.ID) }}{{ continue }}{{ end }}

        {{- /* get nodes edge (unique) */}}
        {{- if and $e.Unique (($t|getAnnotation).HasOperation $.Annotations.RestConfig "read") }}
            // EdgeRead{{ $t.Name|zsingular }}{{ $e.StructField }}ByID maps to "GET /{{ $t.Name|zkebab|zplural }}/{{ $id }}/{{ $e.StructField|zkebab }}".
            func (s *Server) EdgeRead{{ $t.Name|zsingular }}{{ $e.StructField }}ByID(w http.ResponseWriter, r *http.Request) {
                id, err := strconv.Atoi(r.PathValue("id"))
                if s.error(w, r, err) {
                    return
                }
                entity, err := s.db.{{ $t.Name }}.Get(r.Context(), id)
                if s.error(w, r, err) {
                    return
                }
                results, err := EagerLoad{{ $e.Type.Name|zsingular }}(entity.Query{{ $e.StructField }}()).Only(r.Context())
                if s.error(w, r, err) {
                    return
                }
                JSON(w, r, http.StatusOK, results)
            }
        {{- end }}

        {{- /* list nodes edge (non-unique) */}}
        {{- if and (not $e.Unique) (($t|getAnnotation).HasOperation $.Annotations.RestConfig "list") }}
            // EdgeList{{ $t.Name|zsingular }}{{ $e.StructField }}ByID maps to "GET /{{ $t.Name|zkebab|zplural }}/{{ $id }}/{{ $e.StructField|zkebab }}".
            func (s *Server) EdgeList{{ $t.Name|zsingular }}{{ $e.StructField }}ByID(w http.ResponseWriter, r *http.Request) {
                id, err := strconv.Atoi(r.PathValue("id"))
                if s.error(w, r, err) {
                    return
                }
                data := &List{{ $e.Type.Name|zsingular }}Params{}
                if s.error(w, r, Bind(r, data)) {
                    return
                }
                {{- /* TODO: figure out how to do this without first querying the original type. */}}
                entity, err := s.db.{{ $t.Name }}.Get(r.Context(), id)
                if s.error(w, r, err) {
                    return
                }
                results, err := data.Exec(r.Context(), entity.Query{{ $e.StructField }}())
                if s.error(w, r, err) {
                    return
                }
                JSON(w, r, http.StatusOK, results)
            }
        {{- end }}
    {{- end }}

    {{- /* create nodes */}}
    {{- if ($t|getAnnotation).HasOperation $.Annotations.RestConfig "create" }}
        // Create{{ $t.Name|zsingular }} maps to "POST /{{ $t.Name|zkebab|zplural }}".
        func (s *Server) Create{{ $t.Name|zsingular }}(w http.ResponseWriter, r *http.Request) {
            data := &Create{{ $t.Name|zsingular }}Params{}
            if s.error(w, r, Bind(r, data)) {
                return
            }
            results, err := data.Exec(r.Context(), s.db.{{ $t.Name }}.Create(), s.db.{{ $t.Name }}.Query())
            if s.error(w, r, err) {
                return
            }
            JSON(w, r, http.StatusOK, results)
        }
    {{- end }}

    {{- /* update nodes */}}
    {{- if and $t.ID (($t|getAnnotation).HasOperation $.Annotations.RestConfig "update") }}
        // Update{{ $t.Name|zsingular }}ByID maps to "PATCH /{{ $t.Name|zkebab|zplural }}/{{ $id }}".
        func (s *Server) Update{{ $t.Name|zsingular }}ByID(w http.ResponseWriter, r *http.Request) {
            id, err := strconv.Atoi(r.PathValue("id"))
            if s.error(w, r, err) {
                return
            }
            data := &Update{{ $t.Name|zsingular }}Params{}
            if s.error(w, r, Bind(r, data)) {
                return
            }
            results, err := data.Exec(r.Context(), s.db.{{ $t.Name }}.UpdateOneID(id), s.db.{{ $t.Name }}.Query())
            if s.error(w, r, err) {
                return
            }
            JSON(w, r, http.StatusOK, results)
        }
    {{- end }}

    {{- /* delete nodes */}}
    {{- if and $t.ID (($t|getAnnotation).HasOperation $.Annotations.RestConfig "delete") }}
        // Delete{{ $t.Name|zsingular }}ByID maps to "DELETE /{{ $t.Name|zkebab|zplural }}/{{ $id }}".
        func (s *Server) Delete{{ $t.Name|zsingular }}ByID(w http.ResponseWriter, r *http.Request) {
            id, err := strconv.Atoi(r.PathValue("id"))
            if s.error(w, r, err) {
                return
            }
            err = s.db.{{ $t.Name }}.DeleteOneID(id).Exec(r.Context())
            if s.error(w, r, err) {
                return
            }
            w.WriteHeader(http.StatusNoContent)
        }
    {{- end }}
{{ end }}
{{- end }}{{/* end template */}}
